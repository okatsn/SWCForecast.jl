var documenterSearchIndex = {"docs":
[{"location":"log/","page":"Change log","title":"Change log","text":"CurrentModule = SWCForecast","category":"page"},{"location":"log/#Changelog","page":"Change log","title":"Changelog","text":"","category":"section"},{"location":"log/","page":"Change log","title":"Change log","text":"2022-12-02 v0.1.2","category":"page"},{"location":"log/","page":"Change log","title":"Change log","text":"Merge project control files\nGithub pages successfully built","category":"page"},{"location":"log/","page":"Change log","title":"Change log","text":"2022-12-05 v0.1.3","category":"page"},{"location":"log/","page":"Change log","title":"Change log","text":"Changelog\nProject dependent paths/directories generators are moved to project TWAISWCF23a","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SWCForecast","category":"page"},{"location":"#SWCForecast","page":"Home","title":"SWCForecast","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SWCForecast.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# makes a list of docstrings linking to the section/block generated by @autodoc below\nOrder   = [:function, :type]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SWCForecast]\nOrder   = [:function, :type]","category":"page"},{"location":"#Base.merge!-Tuple{Markdown.MD, Vararg{Markdown.MD}}","page":"Home","title":"Base.merge!","text":"SWCForecast.merge!(md0::Markdown.MD, mds::Markdown.MD...)\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge!-Tuple{Markdown.MD, Vararg{Vector}}","page":"Home","title":"Base.merge!","text":"SWCForecast.merge!(md0::Markdown.MD, contents::Vector...)\n\nExample\n\nmd1 = md\"\"\"\n# MyTitle with **Bold** string\nA paragraph starts here\n\"\"\"\n\ncontents = [\n    Markdown.Header{1}([\"Comparison\"]),\n    Markdown.Paragraph(\n        [\"This is the comparision of the section \",\n        Markdown.Bold(md1.content[1].text), # `MyTitle with **Bold** string`\n        \" between results.\"])\n]\n\npreface = merge!(md\"\", contents)\n\nwhich returns the following\n\nComparison\n\nThis is the comparision of the section MyTitle with Bold string between results.\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge!-Tuple{SubMD, Vararg{SubMD}}","page":"Home","title":"Base.merge!","text":"For smd::SubMD, SWCForecast.merge!(smd0::SubMD, smds::SubMD...) merge (using push!) the smd.md.content,smd.header, smd.hash4, smd.path into smd0.\n\nAll smd in smds\n\nExample\n\ncombinedmd = merge!(SubMD(), smds...)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast._create_index_html-Tuple{Any, Any}","page":"Home","title":"SWCForecast._create_index_html","text":"This is modified from Remark._create_index_html\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast._extend-NTuple{4, Any}","page":"Home","title":"SWCForecast._extend","text":"Given the indices w0, w1 indicating the left- and right- non-white boundary of the image, returns the extended indices w0e and w1e by factor cpad_w.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast._group_feature-Tuple{Any}","page":"Home","title":"SWCForecast._group_feature","text":"Given a vector of string str0 with each element being like \"r_o_o_t_suffix\", SWCForecast._group_feature(str0) returns the vector of (root_string, suffix_string).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast._series2supervised-Tuple{Any, Any}","page":"Home","title":"SWCForecast._series2supervised","text":"series2supervised(data, range_shift, range_out)\n\nTansform a time series dataset into a supervised learning dataset.\n\nThe features will always be suffixed by an addtional time shift tag \"t-i\". Also see `splittimetag()andformattime_tag`.\n\nReferences:\n\nhttps://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.addcol_accumulation!-Tuple{Any, Any, Any}","page":"Home","title":"SWCForecast.addcol_accumulation!","text":"Add columns that are derived by accumulating corresponding7 variables.\n\nExample\n\nall_precipstr = names(df, r\"precipitation\")\n\napd = Dict( # time intervals to accumulates precipitation\n    \"1hour\" => 6,\n    \"12hour\" => 6*12,\n    \"1day\" => 6*24,\n    \"2day\" => 6*24*2,\n    \"3day\" => 6*24*3\n)\n\naddcol_accumulation!(df, all_precipstr, apd)\n\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.cccount-Tuple{Any}","page":"Home","title":"SWCForecast.cccount","text":"Of a time series ts, cccount(ts) calculate by default the cumulative counts of elements that approximates zero consecutively.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.chkdatetime-Tuple","page":"Home","title":"SWCForecast.chkdatetime","text":"chkdatetime(v...) use try ... catch ... to check if a vector [yyyy, mm, dd, hh, MM, ss] is a valid datetime. It returns false if it is not an legal date vector array.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.compareresult-Tuple{AbstractString, Union{Regex, Vector{<:AbstractString}}, Any}","page":"Home","title":"SWCForecast.compareresult","text":"Given a vector strvec the last few letters (e.g., [\"ac23\", \"7df6\"]) of the hashes, compareresult(headerstr::AbstractString, strvec::Union{Vector{<:AbstractString}, Regex}, this_dir; fnameexpr=r\"brief\\_report\\.md\") will collect specific sections of the markdown files in the folders that are suffixed by letters in strvec (e.g., \"RESULT_..._0x...7df6\",\"RESULT...0x...ac23\"), with section header matchingheaderstr, and export a comparison markdown file inthis_dir`.\n\nNoted that strvec can be a regular expression such as r\"RESULT\"; see mdpaths for how it searces the target markdown files.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.convert_types-Tuple{Any, Any}","page":"Home","title":"SWCForecast.convert_types","text":"convert_types(df, column_names_types)\n\nConverts the element type of each column to a user-specified type.\n\nArguments\n\ndf: Dataframe for which you want to convert the eltype of each column\ncolumn_names_types: Column names and target types. The type of column_names_types   should be able to be unpacked into column names and target types in a for loop.\n\nReferences\n\nhttps://discourse.julialang.org/t/how-to-change-field-names-and-types-of-a-dataframe/43991/11\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.copyimg-Tuple{Markdown.MD, Any, Any}","page":"Home","title":"SWCForecast.copyimg","text":"Copy images that are referenced in the markdown script md to destinations.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.copysections-Tuple{AbstractString, Union{Regex, Vector{<:AbstractString}}, Any, Function}","page":"Home","title":"SWCForecast.copysections","text":"copysections(headerstr::AbstractString, strvec::Union{Vector{<:AbstractString}, Regex}, result_dir, presentationdir::Function; fnameexpr=expr_defaultmdname, oneslide=false, renameheader=\"\", appendhash=false) reads \"brief_report.md\" file in the target folders whose folder name matches strvec, and returns a vector Markdown.MD objects whose url for local images are relocated. This function is intended to return a vector of Markdown.MD objects with each element being one \"slide\" for Remark.js.\n\nNoted that all images references by target files (those who name \"brief_report.md\") are copied to presentationdir(\"src\", \"assets\", \"img\"), and the referenced paths to the images are relocated to \"assets/img/...\".\n\nKeyword arguments\n\noneslide: strvec given as regular expression, only the first slide is returned if oneslide=true. This is useful when the target section headerstr of all files in result_dir is roughly identical.\nrenameheader: Set md.content[1].text as renameheader. For example, , renameheader=[\"Hello \", Markdown.Bold([\"World\"])]\n\nExample\n\nGet the \"Brief summary\" sections in the markdown files \"brief_report.md\" across all r\"RESULT\" folders, concatenated as slides (separated by ---):\n\nheaderstr = \"## Brief Summary\"\nfolderpattern = r\"RESULT\"\nmds = copysections(headerstr, folderpattern, result_dir, presentationdir; fnameexpr=\"brief_report.md\") |> join\n\nA Literate example (one slide); the oneslide=true option returns only the first.\n\n# ---\n# ## Description\n\nheaderstr = \"### Features\" #hide\ncopysections(headerstr, r\"RESULT\", result_dir, presentationdir;oneslide=true)[1] #hide\n\n# ---\n\nA Literate example that returns slides, where there are total two slides with each page having the \"### Data overview\" and \"### Prediction\" sections:\n\n# ---\n\nstrvec = [\"052c\", \"9a2c\"] #hide\nheaderstr = \"### Data overview\" #hide\nmds = copysections(headerstr, strvec, resultdir0, presentationdir) #hide\nheaderstr = \"### Prediction\" #hide\nmds2 = copysections(headerstr, strvec, resultdir0, presentationdir; appendhash=true) #hide\nelwmerge!(mds, mds2) #hide\njoin(mds) #hide\n\n# ---\n\nTips\n\nThe usage is similar to compareresult, but returns a vector mds::Vector{Markdown.MD} instead of one combined Markdown.MD. Use join(mds) to combine mds into one single Markdown.MD, separated by \"---\".\nUse elwmerge! to combine the results elementwisely; this is useful if you want to have sections combined into one slide.\nAlso see Remark.jl.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.cropwhite-Tuple{AbstractString}","page":"Home","title":"SWCForecast.cropwhite","text":"Given the file path filei, cropwhite(filei::AbstractString; padding_w = 0.5, padding_h = 0.2, saveInplace=false) returns the cropped image\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.datenum-Tuple","page":"Home","title":"SWCForecast.datenum","text":"datenum(v...) does datenum(DateTime(v...)).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.datenum-Tuple{Dates.DateTime}","page":"Home","title":"SWCForecast.datenum","text":"datenum(d::Dates.DateTime) converts a Julia DateTime to a MATLAB style DateNumber. Also see: toordinal\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{AbstractDescription, AbstractString}","page":"Home","title":"SWCForecast.description!","text":"description!(DDT::AbstractDescription, str::AbstractString) update D.description with string str merged to it.\n\nExample\n\nstr = \"\n    [database]\n    server = \"192.168.1.1\"\n    ports = [ 8001, 8001, 8002 ]\n    \";\ndescription!(DDT, str::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{AbstractDescription, Dict}","page":"Home","title":"SWCForecast.description!","text":"description!(D::AbstractDescription, d::Dict) update D.description with d merged to it.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{DescriptCompTree, MLJBase.Machine}","page":"Home","title":"SWCForecast.description!","text":"Given the training machine mach, description!(DDT::DescriptCompTree, mach::Machine) update DDT.description with model information.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{DescriptEnsembleTrees, MLJBase.Machine}","page":"Home","title":"SWCForecast.description!","text":"Given the training machine mach, description!(DDT::DescriptEnsembleTrees, mach::Machine) update DDT.description with model information.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{DescriptOneForest, MLJBase.Machine}","page":"Home","title":"SWCForecast.description!","text":"Given the training machine mach, description!(DDT::DescriptOneForest, mach::Machine) update DDT.description with model information.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.description!-Tuple{DescriptOneTree, MLJBase.Machine}","page":"Home","title":"SWCForecast.description!","text":"Given the training machine mach, description!(DDT::DescriptOneTree, mach::Machine) update DDT.description with model information.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.dict2mdliststr-Tuple{Any}","page":"Home","title":"SWCForecast.dict2mdliststr","text":"Example\n\nfitp = fitted_params(mach)\nbest_fitted_param_model = fitp.best_fitted_params.model # which should be a `Dict`\n\ndict2mdliststr(best_fitted_param_model)\n\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.diffsstable!-Tuple{DataFrames.DataFrame, Any, Any}","page":"Home","title":"SWCForecast.diffsstable!","text":"Of a variable of name varnm, diffsstable!(X0::DataFrame, varnm, tshift) calculates the difference between the non-shifted (suffixed by \"_t0\") and time-shifted (e.g., \"_t-6\"), where the difference is the new column for the series-to-supervised table X0.\n\nExample\n\n    (X0,) = series2supervised(...)\n    diffsstable!(X0, \"precipitation_1hr\", -6)\n\nthat creates a new column diff6_precipitation_1hr = X0[:, \"precipitation_1hr_t0\"] .- X0[:, \"precipitation_1hr_t-6\"].\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.elwmerge!-Tuple{Vector{Markdown.MD}, Vector{Markdown.MD}}","page":"Home","title":"SWCForecast.elwmerge!","text":"Merge mds1 and mds2 elementwisely.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.emptyMD-Tuple{}","page":"Home","title":"SWCForecast.emptyMD","text":"Simply return a empty Markdown.MD object.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.featselemach-Tuple{DataFrames.DataFrame, Any}","page":"Home","title":"SWCForecast.featselemach","text":"featselemach(fullX::DataFrame, tpast::Vector{<:Integer})\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.featselemach-Tuple{DataFrames.DataFrame, MLJModels.FeatureSelector}","page":"Home","title":"SWCForecast.featselemach","text":"featselemach(fullX::DataFrame, selector::FeatureSelector) returns a machine mss ready to be applied as Xs = MLJ.transform(mss, X0)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.feature_summary-Tuple{Any, Any}","page":"Home","title":"SWCForecast.feature_summary","text":"Example\n\nDDTdescript = readdescription(path2toml)\nfeats0 = DDTdescript[\"Model\"][\"features\"]\ntargs0 = DDTdescript[\"Model\"][\"targets\"]\nlist_features, list_targets = feature_summary(feats0, targs0)\n\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.feature_summary-Tuple{Any}","page":"Home","title":"SWCForecast.feature_summary","text":"feats0 = [\n\"pressure_CWB_t0\" ,\n\"pressure_CWB_t-2\" ,\n\"pressure_CWB_t-4\" ,\n\"pressure_CWB_t-6\" ,\n\"pressure_CWB_t-12\" ,\n\"humidity_CWB_t0\" ,\n\"humidity_CWB_t-2\" ,\n\"humidity_CWB_t-4\" ,\n\"humidity_CWB_t-6\" ,\n\"humidity_CWB_t-12\" ,\n]\n\njulia> feature_summary(feats0)\n\"- pressure CWB ($t_i, i=-12,-6,...,0$; total 5 variables) \n - humidity CWB ($t_i, i=-12,-6,...,0$; total 5 variables)\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.featureselectbyheadkey-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}}} where T<:AbstractString","page":"Home","title":"SWCForecast.featureselectbyheadkey","text":"Given feature names of the original table (before time shifted), featureselectbyheadkey(Xtrain, featsets0) returns the table where only variables with column name matches headkey_set in featsets0 are preserved. Noted that headkey in headkey_set must be the first keyword of the column name.\n\nExample\n\nXtrain = DataFrame(\n    \"tmp\" => randn(10),\n    \"tmp_t0\" => randn(10),\n    \"tmp_t-1\" => randn(10),\n    \"humidity\" => randn(10),\n    \"humidity_t0\" => randn(10),\n    \"pressure_t0\" => randn(10),\n    \"pressure_t1\" => randn(10),\n)\n\nfeatsets0 = [\n    [:tmp, :humidity],\n    [:tmp, :pressure],\n    # comma is required even when there is only one union\n]\n\nand\n\njulia> featureselectbyheadkey(Xtrain, featsets0)\n2-element Vector{Vector{Symbol}}:\n [:tmp, :tmp_t0, Symbol(\"tmp_t-1\"), :humidity, :humidity_t0]\n [:tmp, :tmp_t0, Symbol(\"tmp_t-1\"), :pressure_t0, :pressure_t1]\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.filecolumnview-Tuple{Any}","page":"Home","title":"SWCForecast.filecolumnview","text":"Providing the paths to csv files, filecolumnview(paths) gives a plot indicating the available columns of each file.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.filecolumnview-Tuple{Regex, Any}","page":"Home","title":"SWCForecast.filecolumnview","text":"Given a directory dir, filecolumnview(fexpr::Regex, dir) gives a plot indicating the available columns in files under dir that matches fexpr.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.findtrees-Tuple{Vector{MLJBase.Machine}}","page":"Home","title":"SWCForecast.findtrees","text":"Given a vector of machines, findtrees(machs::Vector{Machine}) returns a vector of only Machine{DecisionTreeRegressor, ...}.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.forcontourf-Tuple{Vector, Vector, Any, Any}","page":"Home","title":"SWCForecast.forcontourf","text":"forcontourf(allx::Vector, ally::Vector, xedges, yedges) returns xs, ys, zs for CairoMakie.contourf!(xs, ys, zs).\n\nNoted that length(xs) + 1 = length(xedges).\n\nInput argument\n\nallx, ally are each a vector of values corrsponding to the X and Y coordinates in the plot, indicating all points on the X-Y plane.\nxedges, yedges are each a range specifying the edges for calculating 2D histogram.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.format_time_tag-Tuple{Vector{<:AbstractString}}","page":"Home","title":"SWCForecast.format_time_tag","text":"format_time_tag format time tag into LaTeX maths.\n\nExample\n\njulia> format_time_tag([\"t-1\", \"t-2\", \"t-3\", \"t-4\"])\n\"t_{i=-4,-3,...,-1}\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.formatcolumn-Tuple{DataFrames.DataFrame}","page":"Home","title":"SWCForecast.formatcolumn","text":"Format DataFrame's column if the element type belongs AbstractString:\n\nadd \"\\text{}\"\nadd \"\\\" to any dash (\"_\" => \"\\_\") to prevent error in the LaTeX building stage\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.generatemyslide-Tuple{Any}","page":"Home","title":"SWCForecast.generatemyslide","text":"Similar to Remark.generate(target_dir), generatemyslide(target_dir) generate the slide in the folder target_dir but with my template index.jl and style.css.\n\nTips and Tricks\n\nset image width in \"src/style.css\" at img {max-width: ...}\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.getallfeat-Tuple{AbstractString}","page":"Home","title":"SWCForecast.getallfeat","text":"Get all features (a vector of column names).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.getallfeat-Tuple{Vector}","page":"Home","title":"SWCForecast.getallfeat","text":"Get all features (column names). Returns file names (ks) and columnames of each file (vls).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.getparam_atom-Tuple{MLJBase.Machine}","page":"Home","title":"SWCForecast.getparam_atom","text":"Retrieve the atom model and learned parameters for each atoms\n\nall_machs = fitted_params(mach).machines\nfindparam(mach::Machine{T, N}) where {T, N} = T\n\ntps = all_machs .|> findparam # datatypes\ntargetmodelnamepattern = r\"MLJ.*DecisionTreeRegressor\"\n# which matches:\n# \"MLJEnsembles.DeterministicEnsembleModel{DecisionTreeRegressor}\"\n# \"MLJTuning.DeterministicTunedModel{RandomSearch, MLJEnsembles.DeterministicEnsembleModel{DecisionTreeRegressor}}\"\nidisforest = occursin.(targetmodelnamepattern, string.(tps))\nforests_trained = all_machs[idisforest]\n\n\natomeachforest = getmodel_atom.(forests_trained)\nparameachforest = getparam_atom.(forests_trained)\n# [f.fitresult.fitresult.atom for f in forests_trained]\n\ntreemodels = []\ntreestructs = []\nfor (atom, treestruct) in zip(atomeachforest, parameachforest)\n    push!(treestructs, treestruct)\n    push!(treemodels, fill(atom, length(treestruct)))\nend\n\nlearnedparams_tree = vcat(treestructs...)\natoms = vcat(treemodels...)\nntrees = length(learnedparams_tree)\n# 1st model is TunedModel; 2nd is EnsembleModel\n\nAlso see\n\n[7] build_forest(labels::AbstractVector{T}, features::AbstractMatrix{S}, n_subfeatures, n_trees, partial_sampling, max_depth, min_samples_leaf, min_samples_split) where {S, T<:Float64} in DecisionTree at /.../DecisionTree/iWCbW/src/regression/main.jl:49\nfit!(rf::RandomForestRegressor, X::AbstractMatrix, y::AbstractVector) at /.../DecisionTree/iWCbW/src/scikitlearnAPI.jl:300\nWrappedEnsemble(atom, ensemble::AbstractVector{L}) where L at /.../MLJEnsembles/OsgHR/src/ensembles.jl\nMMI.fitted_params(::RandomForestRegressor, forest) = (forest=forest,) and\nMMI.predict(::RandomForestRegressor, forest, Xnew) at /.../MLJDecisionTreeInterface/CtTJy/src/MLJDecisionTreeInterface.jl:255\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.getsection-Tuple{AbstractString, Any}","page":"Home","title":"SWCForecast.getsection","text":"Give the path of the markdown file, returns a Markdown.MD object of the section headerstr.\n\nExample\n\npath = \"/training/brief_report.md\"\nheaderstr = \"## Description\"\ngetsection(path, headerstr)\n\nIn this example, the section starts from \"## Description\" and ends right before the next level 2 (e.g., \"## blablabla\") or level 1 (e.g., \"# blabla\") header; comments in code fences won't be recognized as a header.\n\nAlso see SubMD.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.group_feature-Tuple{Any}","page":"Home","title":"SWCForecast.group_feature","text":"Given a vector of string str0 with each element being like \"r_o_o_t_suffix\", group_feature(str0) returns an Iterator with each a subgroup of elements having the same root.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.imputemean!-Tuple{Any}","page":"Home","title":"SWCForecast.imputemean!","text":"imputemean!(df) substitute literal nan values with the statistical means. If all missing for a column, value 999 is imputed.\n\nNotice\n\nYou should be aware that imputemean! might does nothing without error message if the input is a view of dataframe (e.g., df[!, Not(:datetime)]).\n\nSee also islnan for literal nan.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.iscommented-Tuple{AbstractString}","page":"Home","title":"SWCForecast.iscommented","text":"iscommented(oneline::AbstractString) returns true if the line is commented by \"#\".\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.iscommentedand-Tuple{AbstractString, Any}","page":"Home","title":"SWCForecast.iscommentedand","text":"iscommentedand(oneline::AbstractString, tag) returns true if the line is commented and starts with tag.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.iseithertpast-Tuple{Any, OrdinalRange}","page":"Home","title":"SWCForecast.iseithertpast","text":"tpast::OrdinalRange is OK.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.iseithertpast-Tuple{Any, Vector{<:Integer}}","page":"Home","title":"SWCForecast.iseithertpast","text":"Given a vector tpast of integers, iseithertpast(featname, tpast) returns true if the string matches either [\"t$t\" for t in tpast] (e.g., [\"t-1\", \"t-5\", ....]).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.islevel-Tuple{Any, Any}","page":"Home","title":"SWCForecast.islevel","text":"Given a object mdc, islevel(mdc, n) returns true if mdc is the type of Markdown.Header{n}\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.islevelleq-Tuple{Any, Any}","page":"Home","title":"SWCForecast.islevelleq","text":"Given a object mdc, islevelleq(mdc, n) returns true if mdc is the type of Markdown.Header{x} where x ≤ n. In brief, it recursively finds if it is a header of higher level (smaller n) until n==0 (false is returned).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.isoutofrange-Tuple{Any, Any, Any}","page":"Home","title":"SWCForecast.isoutofrange","text":"Return true if value is out of the interval between l0 and l1. Noted that if value is missing, nothing, or literally nan (see islnan), it returns false (NOT out-of-range).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.isvarexist-Tuple{Any}","page":"Home","title":"SWCForecast.isvarexist","text":"isvarexist(paths) returns dataframes (df1, df2) in the \"long\" format with each row indicating whether a variable in a file exists. In which, (df, dfi) both have columns [:varname, :fname, :isexist]. In df, all variables are CategoricalArrays; in dfi, all variables are integers for indexing levels(df.varname), levels(df.fname) and levels(df.isexist).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.iswhite-Tuple{ColorTypes.RGBA}","page":"Home","title":"SWCForecast.iswhite","text":"Check if the pixel is white or transparent.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.latextable-Tuple{DataFrames.DataFrame, MIME{Symbol(\"text/latex\")}}","page":"Home","title":"SWCForecast.latextable","text":"latextable(dftmp, MIME(\"text/latex\")) returns a very simple latex table that applies MIME(\"text/latex\"). Other MIME is of-coursely unsupported. This method is experimental following Mimes In Julia: What Are They?.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.latextable-Tuple{Vector{InfoShiftedFeature}}","page":"Home","title":"SWCForecast.latextable","text":"Other Support:\n\nISFs = [InfoShiftedFeature(gf) for gf in group_feature(names(X0))]\nlatextable(ISFs::Vector{InfoShiftedFeature})\n\nwhich is equivalent to\n\ndftmp = DataFrame(\"feature name\" => String[], \"time shift\" => String[])\nfor ISF1 in ISFs\n    push!(dftmp, [ISF1.root, join(string.(ISF1.timeshift), \" ,\")])\nend\nlatextable(dftmp::DataFrame)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.latextable-Tuple{Vector{Pair{String, DataFrames.DataFrame}}}","page":"Home","title":"SWCForecast.latextable","text":"latextable(manytables::Vector{Pair{String,DataFrame}}) is under construction. Noted that\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.learningcurves-Tuple{Vector{<:Pair}, Vector{<:Union{String, Symbol}}}","page":"Home","title":"SWCForecast.learningcurves","text":"learningcurves(tag_machines::Vector{<:Pair}, tags4grid::Vector; kwargs...) accepts keyword arguments kwargs as MLJ.learning_curve; it returns a LearningCurves object instead of curves = MLJ.learning_curve.(machines). In learningcurves there is a testset for checking whether tags4grid fits in length of every output curve.parameter_values.\n\nExample\n\nname_mach = [(tnm => machine(model, X0, y_i)) for (tnm, y_i) in pairs(eachcol(y0))]\nrangef = range(model, :(selector.features), values = featsets)\nftags = [\"feature_set #1\", \"feature_set #2\"]\n\nLC = learningcurves(name_mach,ftags; range = rangef,\n            resampling =  CV(nfolds=5),\n            measure = mae,\n            rngs = 1,\n            rng_name = :(tree.rng)\n            )\n\nIn this case, the output parameter_values for each machine must match ftags in length; otherwise, error will occurred.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.learningcurves-Tuple{Vector{<:Pair}, Vector{<:Vector}}","page":"Home","title":"SWCForecast.learningcurves","text":"If tags4grid is a vector of vector(s), TunedModel is applied instead since MLJ.learning_curve does not support a vector of range.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.level_text-Tuple{Any}","page":"Home","title":"SWCForecast.level_text","text":"Example\n\nlevel_text(\"## Introduction\") returns the header level and the appending string (2, \"Introduction\").\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.load_decision_tree_regressor-Tuple{}","page":"Home","title":"SWCForecast.load_decision_tree_regressor","text":"load_decision_tree_regressor(; package=\"DecisionTree\", kwargs...)\n\nA wrapper function for MLJ @load macro that returns a DecisionTreeRegressor object.\n\nKeywords\n\npackage::AbstractString=\"DecisionTree\": Package that provides DecisionTreeRegressor,   which now has [\"DecisionTree\", \"BetaML\"] to choose from\nkwargs: Valid hyperparameters of DecisionTreeRegressor\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.manyscript-Tuple{Any, Vararg{Pair}}","page":"Home","title":"SWCForecast.manyscript","text":"manyscript(path_to_script0, ind_expr_newstrs::Pair...; append_info = false) creates a new script where the patterns in target lines are replaced by new Strings or SubstitutionStrings.\n\nThis function never overwrite old files; see also pathnorepeat.\n\nIf append_info = true, summary of the modified changes will be appended at the end of the new file.\n\nExample\n\nfor mm = 1:12 # test training/predicting timescale\n    ind_expr_newstr = [66 => r\"\\d+\" => \"1.0mm\",\n                        81 => r\"tpast = \\d+\" => \"tpast = 12\",\n                        81 => r\"tfuture = \\d+\" => \"tfuture = 2\",\n                        All() => r\"includet\" => \"include\"] # replace all \"includet\" by \"include\". The regular expression can match text across lines.\n    manyscript(path_to_script0, ind_expr_newstr...)\nend\n\nTips and Tricks\n\nComment or uncomment a certain line\n\nind_expr_newstr = [\n    66 => r\"^#\\s*\" => \"\", # uncomment line 66\n    77 => r\"(^.)\" => s\"# \\1\", # comment line 77\n    All() => r\"includet\" => \"include\" # replace all \"includet\" by \"include\". In this case the regular expression matches text across lines.\n    ]\nmanyscript(path_to_script0, ind_expr_newstr...)\n\nAlso see reline! and replace.\n\nUse regular expression to find the line for replacement\n\nFor ind_expr_newstr pair, if ind is regular expression, then it searches the only line with that matches the pattern. e.g.,\n\nind_expr_newstr = [All() => r\"includet\" => \"include\",\n                r\"# run month by month\" => r\"^#\\s*\" => \"\", # uncommentat the line\n                r\"# run month by month\" => r\"\\d+\" => \"1.0mm\" # `reline!` on the line having the comment \"# run month by month\"\n                ]\nmanyscript(path_to_script0, ind_expr_newstr...)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.markdownreport-Tuple{AbstractDescription}","page":"Home","title":"SWCForecast.markdownreport","text":"markdownreport(DDT::AbstractDescription) Literate the corresponding template in mdtemplatedir() generating the markdown report with all variables (informations) loaded from DDT.description_dir(\"description.toml\"). It automatically loads \"tmpl_$typeofDDT.jl\" where typeofDDT is the type of DDT.\n\nAlso see description, descrption!, readdescription, writedescription for processing \"description.toml\".\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.markdownreport-Tuple{Any, Any, Any}","page":"Home","title":"SWCForecast.markdownreport","text":"markdownreport(path2toml, path2template, mdreport_dir) Literate the corresponding template path2template generating the markdown report with all variables (informations) loaded from path2toml. The output markdown file is saved in mdreport_dir.\n\nIn your template (e.g., \"tmpl_XXXXXX.jl\" in mdtemplatedir), string \"PATH2TOML\" will be replaced by the variable path2toml.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.markdownreport-Tuple{Any, Any}","page":"Home","title":"SWCForecast.markdownreport","text":"Example\n\ntemplatename = \"tmpl_DescriptOneTree.jl\"\nresult_dir = \"/home/jovyan/swc-forecast-insider/training/decisiontree_20220330/my_result_0000\"\nmarkdownreport(templatename, result_dir; findin=r\"RESULT\")\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdimgpath!-Tuple{Markdown.Image, AbstractString}","page":"Home","title":"SWCForecast.mdimgpath!","text":"mdimgpath!(mdimg::Markdown.Image, dirnm) modify mdimg.url that mdimg.url = joinpath(dirnm, mdimg.url).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdimgpath!-Tuple{Markdown.Image, Function}","page":"Home","title":"SWCForecast.mdimgpath!","text":"mdimgpath!(mdimg::Markdown.Image, dirfun::Function) modify mdimg.url that mdimg.url = dirfun(mdimg.url).\n\nExample\n\nthatresultdir(args...) = joinpath(\"foo\", \"bar\", args...)\nmd1 = md\"\"\"\n# Hello\nthis is a image:\n![](foobar.png)\n\"\"\"\n\nmdimgpath!(md1.content, thatresultdir)\n\n\nreturns\n\nmd1 = md\"\"\"\n# Hello\nthis is a image:\n![](foo/bar/foobar.png)\n\"\"\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdimgpath!-Tuple{Markdown.MD, Any}","page":"Home","title":"SWCForecast.mdimgpath!","text":"mdimgpath!(md::Markdown.MD, dirnm) = mdimgpath!(md.content, dirnm)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdimgpath!-Tuple{SubMD, Any}","page":"Home","title":"SWCForecast.mdimgpath!","text":"mdimgpath!(smd::SubMD, dirnm) = mdimgpath!(smd.md.content, dirnm)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdimgpath!-Tuple{Vector, Any}","page":"Home","title":"SWCForecast.mdimgpath!","text":"Given a vector of Markdown contents mdc, mdimgpath!(mdc::Vector, dirnm) recursively searches Markdown.Image object and join the url (Markdown.Image.url) with dirnm (e.g., ).\n\nExample\n\nBefore:\n\n6-element Vector{Any}:\n Markdown.Header{2}(Any[\"Result\"])\n Markdown.Header{3}(Any[\"Performance－Tree Depth\"])\n Markdown.Paragraph(Any[Markdown.Image(\"tuned_max_depth.png\", \"\")])\n Markdown.Header{3}(Any[\"Predict Result\"])\n Markdown.List(Any[Any[Markdown.Paragraph(Any[\"Best maximum depth is 33.\"])]], -1, false)\n Markdown.Paragraph(Any[Markdown.Image(\"predict_result.png\", \"\")])\n\nChange the url:\n\njulia> mdimgpath!(md.content, \"RESULT_ExpeDeci_0x15b03b01222fec37\")\n\nAfter:\n\n\njulia> md.content\n6-element Vector{Any}:\n Markdown.Header{2}(Any[\"Result\"])\n Markdown.Header{3}(Any[\"Performance－Tree Depth\"])\n Markdown.Paragraph(Any[Markdown.Image(\"RESULT_ExpeDeci_0x15b03b01222fec37/tuned_max_depth.png\", \"\")])\n Markdown.Header{3}(Any[\"Predict Result\"])\n Markdown.List(Any[Any[Markdown.Paragraph(Any[\"Best maximum depth is 33.\"])]], -1, false)\n Markdown.Paragraph(Any[Markdown.Image(\"RESULT_ExpeDeci_0x15b03b01222fec37/predict_result.png\", \"\")])\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdpaths-Tuple{Any, Regex, Any}","page":"Home","title":"SWCForecast.mdpaths","text":"mdpaths(fnameexpr, fldrexpr::Regex, this_dir) returns a list of paths to the markdown files who matches fnameexpr. It searches only the markdown files in the folders in this_dir whose name matches fldrexpr.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdpaths-Tuple{Any, Vector, Any}","page":"Home","title":"SWCForecast.mdpaths","text":"mdpaths(fnameexpr::Regex, strvec::Vector, this_dir::AbstractString) is a shorthand to get the paths to target markdown files.\n\nExample\n\nthis_dir= \"/training/decisiontree_20220309/\"\nfnameexpr = r\"brief\\_report\\.md\"\nstrvec = [\"ac23\", \"7df6\", \"ddf\", \"c37\"]\n\nmdpaths(fnameexpr, strvec, this_dir)\n\nwhich returns\n\n4-element Vector{String}:\n    \"/training/decisiontree_20220309/RESULT_ExpeDeci_0x15b03b01222fec37/brief_report.md\"\n    \"/training/decisiontree_20220309/RESULT_ExpeDeci_0x8a37ffc85c22eddf/brief_report.md\"\n    \"/training/decisiontree_20220309/RESULT_ExpeDeci_0xa14053903286ac23/brief_report.md\"\n    \"/training/decisiontree_20220309/RESULT_ExpeDeci_0xd8a362b941617df6/brief_report.md\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mdreport-Tuple{DescriptOneTree, Any}","page":"Home","title":"SWCForecast.mdreport","text":"(DEPRECATED: use generatemyreport instead)\n\nmdreport(DDT::DescriptOneTree, scriptpath) gives the report in juliamarkdown for script (scriptpath) based on results (DDT.description). The output folder is DDT.description_dir(\"brief_report.md\").\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mkresultdir-Tuple{Any}","page":"Home","title":"SWCForecast.mkresultdir","text":"Given the path to the script file exp_file, mkresultdir return the path to the new directory named with the hash value of the file. That is, once exp_file has been changed, a new directory will be created with its path returned.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mvmean-Tuple{Any, Any}","page":"Home","title":"SWCForecast.mvmean","text":"mvmean(arr, n) retruns an array of element length(arr) - n of moving averaged results.\n\nThis is the function that performs best on https://stackoverflow.com/questions/59562325/moving-average-in-julia.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mvnanmean-Tuple{Any, Any}","page":"Home","title":"SWCForecast.mvnanmean","text":"mvnanmean(arr, n) use mvmean but ignoring NaN. The output array has the same dimensions as the input one, with the first n - 1 element be NaN.\n\nWARNING\n\nYou may have to do imputation first before calculating moving average because ALL NaN are considered to be 0 when calculating moving average; that is, the average will be zero when all elements in the moving window are all NaN.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mycolor_makie_palette-Tuple{}","page":"Home","title":"SWCForecast.mycolor_makie_palette","text":"mycolor_makie_palette()\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mycolor_plots_palette-Tuple{Any, Any}","page":"Home","title":"SWCForecast.mycolor_plots_palette","text":"Example:\n\nmycolor_plots_palette(:tab10, 5) which is equivalently Plots.palette(:tab10, 5)\n\nSee the following for color schemes:\n\nhttps://docs.juliahub.com/MakieGallery/Ql23q/0.2.17/generated/colors.html\nhttps://docs.juliaplots.org/latest/generated/colorschemes/\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.mymovwinmean-Tuple{Vector{Float64}, Any}","page":"Home","title":"SWCForecast.mymovwinmean","text":"my moving average function of poor performance\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.myslideshow-Tuple{Any}","page":"Home","title":"SWCForecast.myslideshow","text":"Since currently Remark.slideshow has some problem:\n\nif documenter=false, code won't be executed as expected\nif documenter=true, some strings in math equations will be misreplaced\n\nmyslideshow(presentation_dir; options=Dict(), title=\"Title\") does the following:\n\nrun Remark.slideshow()\nLiterate.markdown with flavor=Literate.CommonMarkFlavor(), execute=true, mdstrings=true, postprocess=hide_section\ncreate index.html again, while other files in \"build\" left untouched.\n\nExample\n\nmyslideshow(presentation_dir; options = Dict(\"ratio\" => \"16:9\"))\n\nTips and Tricks\n\nyou can use #hide-below and #hide-above to hide the entire section\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.namesx-Tuple{DataFrames.DataFrame, Vector{Regex}}","page":"Home","title":"SWCForecast.namesx","text":"Given df and rselector, namesx(df::DataFrame,rselector::Vector{Regex}) returns non-repeat names matching either pattern.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.narrow_types!-Tuple{Any}","page":"Home","title":"SWCForecast.narrow_types!","text":"narrow_types!(df)\n\nNarrows the eltype of each column to the type that actually exists in the each column of dataframe.\n\nArguments\n\ndf: Dataframe for which you want to narrow the eltype of each column\n\nReferences\n\nhttps://discourse.julialang.org/t/how-to-change-field-names-and-types-of-a-dataframe/43991/9\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.onlycodelines-Tuple{AFile}","page":"Home","title":"SWCForecast.onlycodelines","text":"onlycodelines(script::AbstractString) or onlycodelines(scriptfile::AFile) returns lines that are not commented. See also iscommented\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.print2string-Tuple{Any}","page":"Home","title":"SWCForecast.print2string","text":"Praise master ZK! print2string(printfun) print content to memory and take it out as a String.\n\nExample\n\nprintfun() = MLJDecisionTreeInterface.DT.print_tree(\n    mach.fitresult.fitresult; feature_names=names(mach.fitresult.data[1]))\n\nprint2string(printfun)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.quantileband!-Tuple{Any, Any, Any, Vector{<:Real}, ColorSchemes.ColorScheme}","page":"Home","title":"SWCForecast.quantileband!","text":"quantileband!(ax, xhat, ys, percs::Vector{<:Real}, bandcolormap::ColorSchemes.ColorScheme), where colors are automatically picked from bandcolormap according to percs. It returns (percs, bds) where bd = band!(...).\n\nNoted that percs will be sorted that the order does not matter.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.quantileband!-Union{Tuple{T}, Tuple{Any, Vector{T}, Array{Vector{T}, 1}, Real, Any}} where T<:Real","page":"Home","title":"SWCForecast.quantileband!","text":"quantileband!(ax, xhat::Vector{T}, ys::Vector{Vector{T}}, perc::Real, bandcolor) where T<:Real draw a band of perc quantile to ax. The band covers perc of data where 0 ≤ perc ≤ 1.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.quickdataoverview-Tuple{DataFrames.DataFrame}","page":"Home","title":"SWCForecast.quickdataoverview","text":"quickdataoverview(df_all::DataFrame; gridwidth=Month(1), xname=:datetime, figsize=(23cm, 12cm))\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.readdescription!-Tuple{AbstractDescription}","page":"Home","title":"SWCForecast.readdescription!","text":"readdescription!(D::AbstractDescription) read \"description.toml\" file and return the nested dictionary (i.e., D.description in writedescription); D.description will be overwritten by the loaded one.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.readdescription-Tuple{AbstractString}","page":"Home","title":"SWCForecast.readdescription","text":"readdescription(path2toml::AbstractString) read \"description.toml\" file and return the nested dictionary (i.e., D.description in writedescription).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.recursive_merge!-Tuple{Vararg{AbstractDict}}","page":"Home","title":"SWCForecast.recursive_merge!","text":"See recursive_merge.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.recursive_merge-Tuple{Vararg{AbstractDict}}","page":"Home","title":"SWCForecast.recursive_merge","text":"recursive_merge merges dictionaries combining thier unique key-value pairs together. Similar to merge(d, d1, d2,...), but recursive_merge merge the dictionary recursively that sub-dictionaries are also merged, while merge(d, d1) replace the sub-dict in d by that in d1. This piece of code originally came from this thread: https://discourse.julialang.org/t/multi-layer-dict-merge/27261/2\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.reduce_feature-Tuple{Any}","page":"Home","title":"SWCForecast.reduce_feature","text":"reduce_feature(feats0) returns unique feature names and time tags that are split by split_time_tag.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.refbuildpath-Tuple{Any}","page":"Home","title":"SWCForecast.refbuildpath","text":"Given abspath, refbuildpath(abspath) returns referenced path relative to the .../build/aseets folder.\n\nExample\n\njulia> abspath = \"/home/jovyan/swc-forecast-insider/temp_ppt/build/assets/img/trees_subset_1/tree_root_1.png\"\n\njulia> refbuildpath(abspath)\n\"assets/img/trees_subset_1/tree_root_1.png\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.reline!-Tuple{Any, DataAPI.All, Any, AbstractString}","page":"Home","title":"SWCForecast.reline!","text":"reline!(lines, ind::All, expr, newstr::AbstractString) replace the pattern matched by expr with newstr in the scope of fullscript = join(lines, \" \").\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.reline!-Tuple{Any, Int64, Union{Regex, AbstractString}, AbstractString}","page":"Home","title":"SWCForecast.reline!","text":"reline!(lines, ind::Int, expr::Union{AbstractString, Regex}, newstr::AbstractString) replace string that matches expr in lines[ind] by newstr. newstr can be SubstitutionString. See the documentation of replace and SubstitutionString.\n\nWARNING: if ind is an integer or ind = All(), no warning or error pops if expr matches nothing such that nothing had changed. Use reline!(lines, expr_findline::Regex, expr_replacecode::Regex, newstr::AbstractString) if you want a warning or an error for non-exclusive matching.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.reline!-Tuple{Any, Regex, Union{Regex, AbstractString}, AbstractString}","page":"Home","title":"SWCForecast.reline!","text":"reline!(lines, expr_findline::Regex, expr_replacecode::Union{AbstractString, Regex}, newstr::AbstractString) replace string that matches expr_replacecode in lines[ind] by newstr, where ind indicates the line whose appending comment matches expr_findline. newstr can be SubstitutionString. See the documentation of replace and SubstitutionString.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.removeunreasonables!-Tuple{Any}","page":"Home","title":"SWCForecast.removeunreasonables!","text":"removeunreasonables!(df_all) convert all column-name specific unreasonable values to missing. Noted that missing, nothing and literal nan is not \"unreasonable values\".\n\nNoted that removeunreasonables! will NOT deal with literally Not-a-Number value nor raising an error for any literally Not-a-Number value. See isoutofrange, islnan.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.replacerewrite-Tuple{AbstractString, Any, Any}","page":"Home","title":"SWCForecast.replacerewrite","text":"replace certain keyword in the entire script\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.result_folder_expr-Tuple{Vector{<:AbstractString}}","page":"Home","title":"SWCForecast.result_folder_expr","text":"result_folder_expr(strvec::Vector{<:AbstractString}) returns a single regular expression that should capture the directories for machine learning results. For example, result_folder_expr([\"ac43\"])     \"RESULT_...0x...\"\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.returnchild-Tuple{Markdown.Paragraph}","page":"Home","title":"SWCForecast.returnchild","text":"returnchild(obj::Markdown.Paragraph): Given a Markdown.Paragraph, return the vector obj.text.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.returnchild-Tuple{Union{Markdown.Bold, Markdown.Italic, Markdown.Header}}","page":"Home","title":"SWCForecast.returnchild","text":"returnchild(obj): Given an object obj::Union{Markdown.Italic, Markdown.Bold, Markdown.Header}, return the vector obj.text.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.runallscript-Tuple{Function}","page":"Home","title":"SWCForecast.runallscript","text":"Noted that the script to include shares the scope of SWCForecast module.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.selectbytimeshift-Tuple{Any, Any}","page":"Home","title":"SWCForecast.selectbytimeshift","text":"NOT EXPORTED YET\n\nGiven a vector of strings, selectbytimeshift(namesX, tpast) returns a vector of Bool indicating the elements in namesX matching either [\"t$t\" for t in tpast] (e.g., [\"t-1\", \"t-5\", ....]).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.series2supervised-Tuple{Vararg{Pair}}","page":"Home","title":"SWCForecast.series2supervised","text":"To transform a time series dataset into a supervised learning dataset\n\nExample\n\nA = randn(500,20)\ndf = DataFrame(A, :auto)\nX0,y0 = series_to_supervised(df[:,1:end-1], df[:,end])\nX1,y1 = series2supervised(\n    df[:,1:end-1] => range(-6, -1; step=1),\n    df[:,end] => range(0, 0; step=-1)\n    )\n\nNOTICE!\n\nThe input DataFrame (df) must have complete rows; that is, the corresponding time tag (it might be df.datetime for example) must be consecutive because df is converted to Matrix and shifted using lag.\nThis function filter the dataframe using completecases.\n\nReferences:\n\nhttps://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/\n\nTODO: write test for series2supervised, by making sure the datetime shift is correct (e.g., \"datetimet0\" should always be 1 hour ahead of \"datetimet-6\" for a 10-minute sampling data).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.split_time_tag-Tuple{AbstractString}","page":"Home","title":"SWCForecast.split_time_tag","text":"split_time_tag(str) split the feature name into variable name and the time-shift tag (which should be at the last).\n\nExample\n\njulia> split_time_tag(\"Soil_water_content_10cm_t-24\")\n(\"Soil_water_content_10cm\", \"t-24\")\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.symmquantile-Tuple{Any, Any}","page":"Home","title":"SWCForecast.symmquantile","text":"Get symmetric quantile. E.g., symmquantile(y, 0.15) returns quantile(y, [0.15, 0.85])\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.targetrange-Tuple{Vector, Any, Regex}","page":"Home","title":"SWCForecast.targetrange","text":"Given a Vector, targetrange(mdcs::Vector, nlevel, exprh::Regex) find the target Markdown.Header{nlevel} object whose content matches exprh, returning a range which starts from this header to the next header Markdown.Header{nlevelnext} where nlevelnext ≤ nlevel.\n\nAlso see islevel, islevelleq and targetsection.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.targetsection-Tuple{Markdown.MD, Any, Any}","page":"Home","title":"SWCForecast.targetsection","text":"Given a Markdown.MD object, targetsection(md1::Markdown.MD, nlevel, exprh) returns the section (which is a Vector) that starts with the Markdown.Header{nlevel} object whose content matches exprh and ends until the next header Markdown.Header{nlevelnext} where nlevelnext ≤ nlevel.\n\nAlso see targetrange.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.toordinal-Tuple","page":"Home","title":"SWCForecast.toordinal","text":"toordinal(v...) does toordinal(DateTime(v...)).\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.toordinal-Tuple{Dates.DateTime}","page":"Home","title":"SWCForecast.toordinal","text":"toordinal(dt::DateTime)converts a Julia DateTime to a python style DateNumber. Also see datenum.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.tpastfeatsele-Tuple{Any, Any}","page":"Home","title":"SWCForecast.tpastfeatsele","text":"tpastfeatsele(fullX::DataFrame, tpast::Vector{<:Integer}) returns the DataFrame selected by machine with tpastfeatsele(tpast) selector.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.tpastfeatsele-Tuple{Any}","page":"Home","title":"SWCForecast.tpastfeatsele","text":"Given a vector tpast of integers, tpastfeatsele(tpast) returns a FeatureSelector that keep columns where iseithertpast(columnname, tpast) returns true.\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree, Any}","page":"Home","title":"SWCForecast.tree_structure","text":"Consider deprecate this function\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree}","page":"Home","title":"SWCForecast.tree_structure","text":"Given the machine mach, print the structure of tree to the output variable tree_info::string using MLJDecisionTreeInterface.DT.print_tree.\n\nExample\n\ntree_info = tree_structure(mach)\n\nConsider deprecate this function\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.tree_structure-Tuple{MLJBase.Machine, DescriptCompTree}","page":"Home","title":"SWCForecast.tree_structure","text":"WARNING\n\nYour pipeline must have the field selector = FeatureSelector(), e.g.,\n\n\nmypipe = Pipeline(\n    selector = FeatureSelector(),\n    model = model\n)\n\ntuned_model = TunedModel(;\n    model=mypipe)\n\nmach = machine(\n    tuned_model,\n    X, # a dataframe\n    y, # a vector\n)\n\nmach_report = report(mach)\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.treeinspect!-Tuple{FeatureCounts, DecisionTree.Root}","page":"Home","title":"SWCForecast.treeinspect!","text":"treeinspect!(FC::FeatureCounts, WEE1::DecisionTree.Root) recursively obtain the feature names and splitting thresholds of the tree nodes. Also see FeatureCounts.\n\nExample\n\nFirst, obtain the DecisionTree.Root object from the trained machine containing model of decision tree.\n\nftpr = fitted_params(mach1)\ntransformers = [v for (k, v) in ftpr.fitted_params_given_machine]\nfeatnames = transformers[1].features_to_keep .|> string\nWE = transformers[2].fitresult # WrappedEnsemble\nWEE1 = WE.ensemble[1]\n\nWARNING: how the DecisionTree.Root object WEE1 depends on the structure of your composite model.\n\nSecond, put the DecisionTree.Root object into treeinspect!\n\nFC = FeatureCounts(4) # to at most 4th level\ntreeinspect!(FC, WEE1)\n\nIn final (optional), output the table\n\njulia> DataFrame(FC; feature_names=featnames)\n13×3 DataFrame\n Row │ feature                  value    level\n     │ Any                      Any      Any\n─────┼─────────────────────────────────────────\n   1 │ precipitation_1d_t0      79.3     1\n   2 │ precipitation_3d_t-2     4.9      2\n   3 │ precipitation_12hr_t0    47.25    2\n   4 │ humidity_CWB_t-6         81.5009  3\n   5 │ precipitation_1d_t0      7.75     3\n   6 │ humidity_CWB_t-24        94.2036  3\n   7 │ precipitation_1hr_t-2    2.0      3\n   8 │ precipitation_3d_t-24    0.65     4\n   9 │ air_temperature_t-4      13.703   4\n  10 │ precipitation_1d_t-18    1.4      4\n  11 │ precipitation_12hr_t0    20.25    4\n  12 │ precipitation_12hr_t-12  49.5     4\n  13 │ precipitation_1hr_t0     2.0      4\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.writedescription-Tuple{AbstractDescription}","page":"Home","title":"SWCForecast.writedescription","text":"writedescription(D::AbstractDescription) create file and print D.description to \"description.toml\".\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.FeatureCounts","page":"Home","title":"SWCForecast.FeatureCounts","text":"FeatureCounts of:     maxlevel: the max level of nodes to inspect     featids: the obtained identity number for features at nodes     featvals: the obtained values of thresholds at nodes     atlevels: the current level\n\nExample\n\nFC = FeatureCounts(4)\ntreeinspect!(FC, WEE1) # WEE1 is the DecisionTree.Root object\n\nSee also\n\ntreeinspect!\n\n\n\n\n\n","category":"type"},{"location":"#SWCForecast.InfoShiftedFeature","page":"Home","title":"SWCForecast.InfoShiftedFeature","text":"Example\n\nfeatstrs = [v for v in values(dmachs)][1][1].mach.data[1] |> names\nISFs = [InfoShiftedFeature(gf) for gf in group_feature(rmprefix.(featstrs))]\n\n\n\n\n\n","category":"type"},{"location":"#SWCForecast.LearningCurves","page":"Home","title":"SWCForecast.LearningCurves","text":"Learning Curve Object LC = LearningCurves(tag2machs, tag2grid, curves, parameter_values). It supports getindex of the following to obtain element(s) of curve.measurements for curve in curves; where curves = MLJ.learning_curve.(machines), LC.parameter_values = curves[1].parameter_values (curves[i].parameter_values == curves[j].parameter_values should hold for any i, j in eachindex(curves)).\n\nUse learningcurves only to create LearningCurves objects.\n\nIn indexing LC, the first dimension is indexed to the curve of a certain machine, whereas the second dimension is indexed to the output grid of MLJ.learning_curve (the grid is determined by both range =... and resolution=... keyword arguments). That is, LC[id2mach, id2grid] == curves[id2mach].measurements[id2grid] where machines[id2mach] matches LC.tag2machs[id2mach] and LC.parameter_values[id2grid] matches LC.tag2grid[id2grid]. See also learningcurves.\n\nCurrently supported indexing method:\n\nLC[:,:]\nLC[1,:]\nLC[:,1]\nLC[:, \"pressure\"]\nLC[\"10cm\", :]\n\nIndexing to multiple rows/columns is not supported yet.\n\n\n\n\n\n","category":"type"},{"location":"#SWCForecast.MyPath","page":"Home","title":"SWCForecast.MyPath","text":"a type that should be a path\n\n\n\n\n\n","category":"type"},{"location":"#SWCForecast.SubMD-Tuple{Any, Any}","page":"Home","title":"SWCForecast.SubMD","text":"Given the path to the markdown file and a string headermatch, SubMD(path, headermatch) returns a SubMD object.\n\nFields\n\nmd::Markdown.MD\nheader::Vector{AbstractString} # e.g., `[\"## Introduction\"]`\nhash4::Vector{AbstractString} # e.g., `[\"c4a3\"]`\npath::Vector{AbstractString} # e.g. `\"/training/decisiontree_20220309/RESULT_ExpeDeci_0x15b03b01222fec37/brief_report.md\"`\n\n\n\n\n\n","category":"method"},{"location":"#SWCForecast.SubMD-Tuple{}","page":"Home","title":"SWCForecast.SubMD","text":"SubMD() create an empty SubMD object.\n\n\n\n\n\n","category":"method"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"CurrentModule = SWCForecast","category":"page"},{"location":"namesensitive/#Name-sensitive-functions","page":"Name-sensitive Functions","title":"Name-sensitive functions","text":"","category":"section"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"Documentation for SWCForecast.","category":"page"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"# makes a list of docstrings linking to the section/block generated by @autodoc below\nOrder   = [:function, :type]","category":"page"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"Modules = [SWCForecast]\nOrder   = [:function, :type]\nusing FileTools\nflist = filelist(r\".+\\.jl\", joinpath(dirname(pathof(SWCForecast)),\"namesensitive\"))\nPages = flist","category":"page"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"!!! note If error occurred in this page     Try this     ```jldoctest     using FileTools, SWCForecast     flist = filelist(r\".+.jl\", joinpath(dirname(pathof(SWCForecast)),\"namesensitive\"))     occursin(\"src/namesensitive/featureselect.jl\", flist[1])","category":"page"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"# output\n\ntrue\n```","category":"page"},{"location":"namesensitive/","page":"Name-sensitive Functions","title":"Name-sensitive Functions","text":"end","category":"page"}]
}
