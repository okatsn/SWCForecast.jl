<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SWCForecast.jl</title><link rel="canonical" href="https://okatsn.github.io/SWCForecast.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SWCForecast.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/okatsn/SWCForecast.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SWCForecast"><a class="docs-heading-anchor" href="#SWCForecast">SWCForecast</a><a id="SWCForecast-1"></a><a class="docs-heading-anchor-permalink" href="#SWCForecast" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/okatsn/SWCForecast.jl">SWCForecast</a>.</p><ul><li><a href="#SWCForecast.FeatureCounts"><code>SWCForecast.FeatureCounts</code></a></li><li><a href="#SWCForecast.InfoShiftedFeature"><code>SWCForecast.InfoShiftedFeature</code></a></li><li><a href="#SWCForecast.MyPath"><code>SWCForecast.MyPath</code></a></li><li><a href="#SWCForecast.SubMD-Tuple{}"><code>SWCForecast.SubMD</code></a></li><li><a href="#SWCForecast.SubMD-Tuple{Any, Any}"><code>SWCForecast.SubMD</code></a></li><li><a href="#Base.merge!-Tuple{Markdown.MD, Vararg{Vector}}"><code>Base.merge!</code></a></li><li><a href="#Base.merge!-Tuple{SubMD, Vararg{SubMD}}"><code>Base.merge!</code></a></li><li><a href="#Base.merge!-Tuple{Markdown.MD, Vararg{Markdown.MD}}"><code>Base.merge!</code></a></li><li><a href="#SWCForecast._create_index_html-Tuple{Any, Any}"><code>SWCForecast._create_index_html</code></a></li><li><a href="#SWCForecast._extend-NTuple{4, Any}"><code>SWCForecast._extend</code></a></li><li><a href="#SWCForecast._group_feature-Tuple{Any}"><code>SWCForecast._group_feature</code></a></li><li><a href="#SWCForecast._series2supervised-Tuple{Any, Any}"><code>SWCForecast._series2supervised</code></a></li><li><a href="#SWCForecast.addcol_accumulation!-Tuple{Any, Any, Any}"><code>SWCForecast.addcol_accumulation!</code></a></li><li><a href="#SWCForecast.blankaxis!-Union{Tuple{T}, Tuple{Any, T, T, T, T}} where T&lt;:AbstractFloat"><code>SWCForecast.blankaxis!</code></a></li><li><a href="#SWCForecast.cccount-Tuple{Any}"><code>SWCForecast.cccount</code></a></li><li><a href="#SWCForecast.checkparse-Tuple{DataFrames.DataFrame, Any}"><code>SWCForecast.checkparse</code></a></li><li><a href="#SWCForecast.chkdatetime-Tuple"><code>SWCForecast.chkdatetime</code></a></li><li><a href="#SWCForecast.chknnm-Tuple{Any}"><code>SWCForecast.chknnm</code></a></li><li><a href="#SWCForecast.compareresult-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any}"><code>SWCForecast.compareresult</code></a></li><li><a href="#SWCForecast.convert_types-Tuple{Any, Any}"><code>SWCForecast.convert_types</code></a></li><li><a href="#SWCForecast.convertdf2!-Tuple{Any, Any}"><code>SWCForecast.convertdf2!</code></a></li><li><a href="#SWCForecast.copyimg-Tuple{Markdown.MD, Any, Any}"><code>SWCForecast.copyimg</code></a></li><li><a href="#SWCForecast.copysections-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any, Function}"><code>SWCForecast.copysections</code></a></li><li><a href="#SWCForecast.cropwhite-Tuple{AbstractString}"><code>SWCForecast.cropwhite</code></a></li><li><a href="#SWCForecast.datenum-Tuple"><code>SWCForecast.datenum</code></a></li><li><a href="#SWCForecast.datenum-Tuple{Dates.DateTime}"><code>SWCForecast.datenum</code></a></li><li><a href="#SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector}"><code>SWCForecast.datetimeticks!</code></a></li><li><a href="#SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector, Dates.DatePeriod}"><code>SWCForecast.datetimeticks!</code></a></li><li><a href="#SWCForecast.describeinstr-Tuple{Any}"><code>SWCForecast.describeinstr</code></a></li><li><a href="#SWCForecast.description!-Tuple{DescriptCompTree, MLJBase.Machine}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.description!-Tuple{DescriptOneTree, MLJBase.Machine}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.description!-Tuple{AbstractDescription, AbstractString}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.description!-Tuple{DescriptOneForest, MLJBase.Machine}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.description!-Tuple{AbstractDescription, Dict}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.description!-Tuple{DescriptEnsembleTrees, MLJBase.Machine}"><code>SWCForecast.description!</code></a></li><li><a href="#SWCForecast.dict2mdliststr-Tuple{Any}"><code>SWCForecast.dict2mdliststr</code></a></li><li><a href="#SWCForecast.diffsstable!-Tuple{DataFrames.DataFrame, Any, Any}"><code>SWCForecast.diffsstable!</code></a></li><li><a href="#SWCForecast.dropmissingcol-Tuple{Any}"><code>SWCForecast.dropmissingcol</code></a></li><li><a href="#SWCForecast.elwmerge!-Tuple{Vector{Markdown.MD}, Vector{Markdown.MD}}"><code>SWCForecast.elwmerge!</code></a></li><li><a href="#SWCForecast.emptyMD-Tuple{}"><code>SWCForecast.emptyMD</code></a></li><li><a href="#SWCForecast.expandylim!-Tuple{Any, Any}"><code>SWCForecast.expandylim!</code></a></li><li><a href="#SWCForecast.feature_summary-Tuple{Any, Any}"><code>SWCForecast.feature_summary</code></a></li><li><a href="#SWCForecast.feature_summary-Tuple{Any}"><code>SWCForecast.feature_summary</code></a></li><li><a href="#SWCForecast.featureselectbyheadkey-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}}} where T&lt;:AbstractString"><code>SWCForecast.featureselectbyheadkey</code></a></li><li><a href="#SWCForecast.filecolumnview-Tuple{Regex, Any}"><code>SWCForecast.filecolumnview</code></a></li><li><a href="#SWCForecast.filecolumnview-Tuple{Any}"><code>SWCForecast.filecolumnview</code></a></li><li><a href="#SWCForecast.findtrees-Tuple{Vector{MLJBase.Machine}}"><code>SWCForecast.findtrees</code></a></li><li><a href="#SWCForecast.forcontourf-Tuple{Vector, Vector, Any, Any}"><code>SWCForecast.forcontourf</code></a></li><li><a href="#SWCForecast.format_time_tag-Tuple{Vector{&lt;:AbstractString}}"><code>SWCForecast.format_time_tag</code></a></li><li><a href="#SWCForecast.formatcolumn-Tuple{DataFrames.DataFrame}"><code>SWCForecast.formatcolumn</code></a></li><li><a href="#SWCForecast.generatemyslide-Tuple{Any}"><code>SWCForecast.generatemyslide</code></a></li><li><a href="#SWCForecast.get1var-Tuple{Vector}"><code>SWCForecast.get1var</code></a></li><li><a href="#SWCForecast.get1var-Tuple{DataFrames.DataFrame, Union{Regex, InvertedIndices.InvertedIndex}}"><code>SWCForecast.get1var</code></a></li><li><a href="#SWCForecast.get1var-Tuple{DataFrames.DataFrame}"><code>SWCForecast.get1var</code></a></li><li><a href="#SWCForecast.getallfeat-Tuple{Vector}"><code>SWCForecast.getallfeat</code></a></li><li><a href="#SWCForecast.getallfeat-Tuple{AbstractString}"><code>SWCForecast.getallfeat</code></a></li><li><a href="#SWCForecast.getparam_atom-Tuple{MLJBase.Machine}"><code>SWCForecast.getparam_atom</code></a></li><li><a href="#SWCForecast.getsection-Tuple{AbstractString, Any}"><code>SWCForecast.getsection</code></a></li><li><a href="#SWCForecast.getxylimits-Tuple{Any}"><code>SWCForecast.getxylimits</code></a></li><li><a href="#SWCForecast.group_feature-Tuple{Any}"><code>SWCForecast.group_feature</code></a></li><li><a href="#SWCForecast.ifstrparse-Tuple{Any, Any}"><code>SWCForecast.ifstrparse</code></a></li><li><a href="#SWCForecast.imputemean!-Tuple{Any}"><code>SWCForecast.imputemean!</code></a></li><li><a href="#SWCForecast.isableparse-Tuple{Any, Any}"><code>SWCForecast.isableparse</code></a></li><li><a href="#SWCForecast.iscommented-Tuple{AbstractString}"><code>SWCForecast.iscommented</code></a></li><li><a href="#SWCForecast.iscommentedand-Tuple{AbstractString, Any}"><code>SWCForecast.iscommentedand</code></a></li><li><a href="#SWCForecast.islevel-Tuple{Any, Any}"><code>SWCForecast.islevel</code></a></li><li><a href="#SWCForecast.islevelleq-Tuple{Any, Any}"><code>SWCForecast.islevelleq</code></a></li><li><a href="#SWCForecast.isvarexist-Tuple{Any}"><code>SWCForecast.isvarexist</code></a></li><li><a href="#SWCForecast.iswhite-Tuple{ColorTypes.RGBA}"><code>SWCForecast.iswhite</code></a></li><li><a href="#SWCForecast.latextable-Tuple{DataFrames.DataFrame, MIME{Symbol(&quot;text/latex&quot;)}}"><code>SWCForecast.latextable</code></a></li><li><a href="#SWCForecast.latextable-Tuple{Vector{InfoShiftedFeature}}"><code>SWCForecast.latextable</code></a></li><li><a href="#SWCForecast.latextable-Tuple{Vector{Pair{String, DataFrames.DataFrame}}}"><code>SWCForecast.latextable</code></a></li><li><a href="#SWCForecast.level_text-Tuple{Any}"><code>SWCForecast.level_text</code></a></li><li><a href="#SWCForecast.load_decision_tree_regressor-Tuple{}"><code>SWCForecast.load_decision_tree_regressor</code></a></li><li><a href="#SWCForecast.manyscript-Tuple{Any, Vararg{Pair}}"><code>SWCForecast.manyscript</code></a></li><li><a href="#SWCForecast.markdownreport-Tuple{AbstractDescription}"><code>SWCForecast.markdownreport</code></a></li><li><a href="#SWCForecast.markdownreport-Tuple{Any, Any, Any}"><code>SWCForecast.markdownreport</code></a></li><li><a href="#SWCForecast.markdownreport-Tuple{Any, Any}"><code>SWCForecast.markdownreport</code></a></li><li><a href="#SWCForecast.mdimgpath!-Tuple{Vector, Any}"><code>SWCForecast.mdimgpath!</code></a></li><li><a href="#SWCForecast.mdimgpath!-Tuple{Markdown.Image, Function}"><code>SWCForecast.mdimgpath!</code></a></li><li><a href="#SWCForecast.mdimgpath!-Tuple{Markdown.MD, Any}"><code>SWCForecast.mdimgpath!</code></a></li><li><a href="#SWCForecast.mdimgpath!-Tuple{Markdown.Image, AbstractString}"><code>SWCForecast.mdimgpath!</code></a></li><li><a href="#SWCForecast.mdimgpath!-Tuple{SubMD, Any}"><code>SWCForecast.mdimgpath!</code></a></li><li><a href="#SWCForecast.mdpaths-Tuple{Any, Regex, Any}"><code>SWCForecast.mdpaths</code></a></li><li><a href="#SWCForecast.mdpaths-Tuple{Any, Vector, Any}"><code>SWCForecast.mdpaths</code></a></li><li><a href="#SWCForecast.mdreport-Tuple{DescriptOneTree, Any}"><code>SWCForecast.mdreport</code></a></li><li><a href="#SWCForecast.mkresultdir-Tuple{Any}"><code>SWCForecast.mkresultdir</code></a></li><li><a href="#SWCForecast.mvmean-Tuple{Any, Any}"><code>SWCForecast.mvmean</code></a></li><li><a href="#SWCForecast.mvnanmean-Tuple{Any, Any}"><code>SWCForecast.mvnanmean</code></a></li><li><a href="#SWCForecast.mycolor_makie_palette-Tuple{}"><code>SWCForecast.mycolor_makie_palette</code></a></li><li><a href="#SWCForecast.mycolor_plots_palette-Tuple{Any, Any}"><code>SWCForecast.mycolor_plots_palette</code></a></li><li><a href="#SWCForecast.mymovwinmean-Tuple{Vector{Float64}, Any}"><code>SWCForecast.mymovwinmean</code></a></li><li><a href="#SWCForecast.myslideshow-Tuple{Any}"><code>SWCForecast.myslideshow</code></a></li><li><a href="#SWCForecast.narrow_types!-Tuple{Any}"><code>SWCForecast.narrow_types!</code></a></li><li><a href="#SWCForecast.onlycodelines-Tuple{AFile}"><code>SWCForecast.onlycodelines</code></a></li><li><a href="#SWCForecast.print2string-Tuple{Any}"><code>SWCForecast.print2string</code></a></li><li><a href="#SWCForecast.quantileband!-Tuple{Any, Any, Any, Vector{&lt;:Real}, ColorSchemes.ColorScheme}"><code>SWCForecast.quantileband!</code></a></li><li><a href="#SWCForecast.quantileband!-Union{Tuple{T}, Tuple{Any, Vector{T}, Array{Vector{T}, 1}, Real, Any}} where T&lt;:Real"><code>SWCForecast.quantileband!</code></a></li><li><a href="#SWCForecast.quickdataoverview-Tuple{DataFrames.DataFrame}"><code>SWCForecast.quickdataoverview</code></a></li><li><a href="#SWCForecast.readdescription-Tuple{AbstractString}"><code>SWCForecast.readdescription</code></a></li><li><a href="#SWCForecast.readdescription!-Tuple{AbstractDescription}"><code>SWCForecast.readdescription!</code></a></li><li><a href="#SWCForecast.recursive_merge-Tuple{Vararg{AbstractDict}}"><code>SWCForecast.recursive_merge</code></a></li><li><a href="#SWCForecast.recursive_merge!-Tuple{Vararg{AbstractDict}}"><code>SWCForecast.recursive_merge!</code></a></li><li><a href="#SWCForecast.reduce_feature-Tuple{Any}"><code>SWCForecast.reduce_feature</code></a></li><li><a href="#SWCForecast.reducetype-Tuple{AbstractArray}"><code>SWCForecast.reducetype</code></a></li><li><a href="#SWCForecast.refbuildpath-Tuple{Any}"><code>SWCForecast.refbuildpath</code></a></li><li><a href="#SWCForecast.reline!-Tuple{Any, Int64, Union{Regex, AbstractString}, AbstractString}"><code>SWCForecast.reline!</code></a></li><li><a href="#SWCForecast.reline!-Tuple{Any, Regex, Union{Regex, AbstractString}, AbstractString}"><code>SWCForecast.reline!</code></a></li><li><a href="#SWCForecast.reline!-Tuple{Any, DataAPI.All, Any, AbstractString}"><code>SWCForecast.reline!</code></a></li><li><a href="#SWCForecast.replacerewrite-Tuple{AbstractString, Any, Any}"><code>SWCForecast.replacerewrite</code></a></li><li><a href="#SWCForecast.result_folder_expr-Tuple{Vector{&lt;:AbstractString}}"><code>SWCForecast.result_folder_expr</code></a></li><li><a href="#SWCForecast.returnchild-Tuple{Union{Markdown.Bold, Markdown.Italic, Markdown.Header}}"><code>SWCForecast.returnchild</code></a></li><li><a href="#SWCForecast.returnchild-Tuple{Markdown.Paragraph}"><code>SWCForecast.returnchild</code></a></li><li><a href="#SWCForecast.runallscript-Tuple{Function}"><code>SWCForecast.runallscript</code></a></li><li><a href="#SWCForecast.secondyaxis-Tuple{Any}"><code>SWCForecast.secondyaxis</code></a></li><li><a href="#SWCForecast.selectname-Tuple{DataFrames.DataFrame, Any}"><code>SWCForecast.selectname</code></a></li><li><a href="#SWCForecast.selectnames-Tuple{Any, Vararg{Any}}"><code>SWCForecast.selectnames</code></a></li><li><a href="#SWCForecast.series2supervised-Tuple{Vararg{Pair}}"><code>SWCForecast.series2supervised</code></a></li><li><a href="#SWCForecast.shrinkylim!-Tuple{Any, Vector{&lt;:Number}}"><code>SWCForecast.shrinkylim!</code></a></li><li><a href="#SWCForecast.split_time_tag-Tuple{AbstractString}"><code>SWCForecast.split_time_tag</code></a></li><li><a href="#SWCForecast.symmquantile-Tuple{Any, Any}"><code>SWCForecast.symmquantile</code></a></li><li><a href="#SWCForecast.targetrange-Tuple{Vector, Any, Regex}"><code>SWCForecast.targetrange</code></a></li><li><a href="#SWCForecast.targetsection-Tuple{Markdown.MD, Any, Any}"><code>SWCForecast.targetsection</code></a></li><li><a href="#SWCForecast.toordinal-Tuple{Dates.DateTime}"><code>SWCForecast.toordinal</code></a></li><li><a href="#SWCForecast.toordinal-Tuple"><code>SWCForecast.toordinal</code></a></li><li><a href="#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree, Any}"><code>SWCForecast.tree_structure</code></a></li><li><a href="#SWCForecast.tree_structure-Tuple{MLJBase.Machine, DescriptCompTree}"><code>SWCForecast.tree_structure</code></a></li><li><a href="#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree}"><code>SWCForecast.tree_structure</code></a></li><li><a href="#SWCForecast.treeinspect!-Tuple{FeatureCounts, DecisionTree.Root}"><code>SWCForecast.treeinspect!</code></a></li><li><a href="#SWCForecast.writedescription-Tuple{AbstractDescription}"><code>SWCForecast.writedescription</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.FeatureCounts" href="#SWCForecast.FeatureCounts"><code>SWCForecast.FeatureCounts</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FeatureCounts</code> of:     maxlevel: the max level of nodes to inspect     featids: the obtained identity number for features at nodes     featvals: the obtained values of thresholds at nodes     atlevels: the current level</p><p><strong>Example</strong></p><pre><code class="language-julia">FC = FeatureCounts(4)
treeinspect!(FC, WEE1) # WEE1 is the DecisionTree.Root object</code></pre><p><strong>See also</strong></p><ul><li>treeinspect!</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L194-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.InfoShiftedFeature" href="#SWCForecast.InfoShiftedFeature"><code>SWCForecast.InfoShiftedFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>Example</strong></p><pre><code class="language-none">featstrs = [v for v in values(dmachs)][1][1].mach.data[1] |&gt; names
ISFs = [InfoShiftedFeature(gf) for gf in group_feature(rmprefix.(featstrs))]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/infostructs.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.MyPath" href="#SWCForecast.MyPath"><code>SWCForecast.MyPath</code></a> — <span class="docstring-category">Type</span></header><section><div><p>a type that should be a path</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/project_setup.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.SubMD-Tuple{Any, Any}" href="#SWCForecast.SubMD-Tuple{Any, Any}"><code>SWCForecast.SubMD</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the <code>path</code> to the markdown file and a string <code>headermatch</code>, <code>SubMD(path, headermatch)</code> returns a <code>SubMD</code> object.</p><p><strong>Fields</strong></p><pre><code class="language-none">md::Markdown.MD
header::Vector{AbstractString} # e.g., `[&quot;## Introduction&quot;]`
hash4::Vector{AbstractString} # e.g., `[&quot;c4a3&quot;]`
path::Vector{AbstractString} # e.g. `&quot;/training/decisiontree_20220309/RESULT_ExpeDeci_0x15b03b01222fec37/brief_report.md&quot;`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L305-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.SubMD-Tuple{}" href="#SWCForecast.SubMD-Tuple{}"><code>SWCForecast.SubMD</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>SubMD()</code> create an empty <code>SubMD</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L325-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{Markdown.MD, Vararg{Markdown.MD}}" href="#Base.merge!-Tuple{Markdown.MD, Vararg{Markdown.MD}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>SWCForecast.merge!(md0::Markdown.MD, mds::Markdown.MD...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L403-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{Markdown.MD, Vararg{Vector}}" href="#Base.merge!-Tuple{Markdown.MD, Vararg{Vector}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>SWCForecast.merge!(md0::Markdown.MD, contents::Vector...)</code></p><p><strong>Example</strong></p><pre><code class="language-julia">md1 = md&quot;&quot;&quot;
# MyTitle with **Bold** string
A paragraph starts here
&quot;&quot;&quot;

contents = [
    Markdown.Header{1}([&quot;Comparison&quot;]),
    Markdown.Paragraph(
        [&quot;This is the comparision of the section &quot;,
        Markdown.Bold(md1.content[1].text), # `MyTitle with **Bold** string`
        &quot; between results.&quot;])
]

preface = merge!(md&quot;&quot;, contents)</code></pre><p>which returns the following</p><p><strong>Comparison</strong></p><p>This is the comparision of the section MyTitle with <strong>Bold</strong> string between results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L413-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{SubMD, Vararg{SubMD}}" href="#Base.merge!-Tuple{SubMD, Vararg{SubMD}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For <code>smd::SubMD</code>, <code>SWCForecast.merge!(smd0::SubMD, smds::SubMD...)</code> merge (using <code>push!</code>) the <code>smd.md.content</code>,<code>smd.header</code>, <code>smd.hash4</code>, <code>smd.path</code> into <code>smd0</code>.</p><p>All <code>smd</code> in <code>smds</code></p><p><strong>Example</strong></p><pre><code class="language-julia">combinedmd = merge!(SubMD(), smds...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L382-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast._create_index_html-Tuple{Any, Any}" href="#SWCForecast._create_index_html-Tuple{Any, Any}"><code>SWCForecast._create_index_html</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is modified from <code>Remark._create_index_html</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/slideshow.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast._extend-NTuple{4, Any}" href="#SWCForecast._extend-NTuple{4, Any}"><code>SWCForecast._extend</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the indices <code>w0</code>, <code>w1</code> indicating the left- and right- non-white boundary of the image, returns the extended indices <code>w0e</code> and <code>w1e</code> by factor <code>cpad_w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/imgproc/imgcrop.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast._group_feature-Tuple{Any}" href="#SWCForecast._group_feature-Tuple{Any}"><code>SWCForecast._group_feature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of string <code>str0</code> with each element being like <code>&quot;r_o_o_t_suffix&quot;</code>, <code>SWCForecast._group_feature(str0)</code> returns the vector of <code>(root_string, suffix_string)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/feature_summary.jl#L85-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast._series2supervised-Tuple{Any, Any}" href="#SWCForecast._series2supervised-Tuple{Any, Any}"><code>SWCForecast._series2supervised</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">series2supervised(data, range_shift, range_out)</code></pre><p>Tansform a time series dataset into a supervised learning dataset.</p><p>The features will always be suffixed by an addtional time shift tag &quot;<em>t-i&quot;. Also see `split</em>time<em>tag()<code>and</code>format</em>time_tag`.</p><p><strong>References:</strong></p><ul><li>https://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/series2supervised.jl#L12-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.addcol_accumulation!-Tuple{Any, Any, Any}" href="#SWCForecast.addcol_accumulation!-Tuple{Any, Any, Any}"><code>SWCForecast.addcol_accumulation!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add columns that are derived by accumulating corresponding7 variables.</p><p><strong>Example</strong></p><pre><code class="language-julia">all_precipstr = names(df, r&quot;precipitation&quot;)

apd = Dict( # time intervals to accumulates precipitation
    &quot;1hour&quot; =&gt; 6,
    &quot;12hour&quot; =&gt; 6*12,
    &quot;1day&quot; =&gt; 6*24,
    &quot;2day&quot; =&gt; 6*24*2,
    &quot;3day&quot; =&gt; 6*24*3
)

addcol_accumulation!(df, all_precipstr, apd)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataprocessing/precipitation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.blankaxis!-Union{Tuple{T}, Tuple{Any, T, T, T, T}} where T&lt;:AbstractFloat" href="#SWCForecast.blankaxis!-Union{Tuple{T}, Tuple{Any, T, T, T, T}} where T&lt;:AbstractFloat"><code>SWCForecast.blankaxis!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>blankaxis!(fpos, xmin::T, ymin::T, xmax::T, ymax::T) where {T&lt;:AbstractFloat}</code> creates an empty Makie Axis object at grid position <code>fpos</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">f = Figure(;resolution=(1400,1000))
gleft = f[1:3, 1] = GridLayout()
gright = f[1:3, 2:3] = GridLayout()
fpos = gright[0, :]
blankaxis!(fpos, xmin, ymin, xmax, ymax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.cccount-Tuple{Any}" href="#SWCForecast.cccount-Tuple{Any}"><code>SWCForecast.cccount</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Of a time series <code>ts</code>, <code>cccount(ts)</code> calculate by default the cumulative counts of elements that approximates zero consecutively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataprocessing/precipitation.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.checkparse-Tuple{DataFrames.DataFrame, Any}" href="#SWCForecast.checkparse-Tuple{DataFrames.DataFrame, Any}"><code>SWCForecast.checkparse</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>checkparse(df::DataFrame, TYPE)</code> check if all elements column variables can be parsed to a specific data <code>TYPE</code>. It returns a dictionary with the column names of <code>df</code> as its keys, and a vector of DataType and anything that cannot be parsed to <code>TYPE</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.chkdatetime-Tuple" href="#SWCForecast.chkdatetime-Tuple"><code>SWCForecast.chkdatetime</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>chkdatetime(v...)</code> use <code>try ... catch ...</code> to check if a vector <code>[yyyy, mm, dd, hh, MM, ss]</code> is a valid datetime. It returns <code>false</code> if it is not an legal date vector array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/datenum.jl#L32-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.chknnm-Tuple{Any}" href="#SWCForecast.chknnm-Tuple{Any}"><code>SWCForecast.chknnm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>chknnm(df)</code> check if DataFrame <code>df</code> contains missing values or NaN.     Use this before input <code>df</code> into machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L196-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.compareresult-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any}" href="#SWCForecast.compareresult-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any}"><code>SWCForecast.compareresult</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector <code>strvec</code> the last few letters (e.g., [&quot;ac23&quot;, &quot;7df6&quot;]) of the hashes, <code>compareresult(headerstr::AbstractString, strvec::Union{Vector{&lt;:AbstractString}, Regex}, this_dir; fnameexpr=r&quot;brief\_report\.md&quot;)</code> will collect specific sections of the markdown files in the folders that are suffixed by letters in <code>strvec</code> (e.g., <code>&quot;RESULT_..._0x...7df6&quot;,</code>&quot;RESULT<em>...</em>0x...ac23&quot;<code>), with section header matching</code>headerstr<code>, and export a comparison markdown file in</code>this_dir`.</p><p>Noted that <code>strvec</code> can be a regular expression such as <code>r&quot;RESULT&quot;</code>; see <code>mdpaths</code> for how it searces the target markdown files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.convert_types-Tuple{Any, Any}" href="#SWCForecast.convert_types-Tuple{Any, Any}"><code>SWCForecast.convert_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_types(df, column_names_types)</code></pre><p>Converts the element type of each column to a user-specified type.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: Dataframe for which you want to convert the <code>eltype</code> of each column</li><li><code>column_names_types</code>: Column names and target types. The type of <code>column_names_types</code>   should be able to be unpacked into column names and target types in a for loop.</li></ul><p><strong>References</strong></p><p>https://discourse.julialang.org/t/how-to-change-field-names-and-types-of-a-dataframe/43991/11</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/utils/dataframe.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.convertdf2!-Tuple{Any, Any}" href="#SWCForecast.convertdf2!-Tuple{Any, Any}"><code>SWCForecast.convertdf2!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>convertdf2!(df, TYPE)</code> convert all elements in <code>df</code> to the type of <code>TYPE</code>, ignoring <code>NaN</code> and <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.copyimg-Tuple{Markdown.MD, Any, Any}" href="#SWCForecast.copyimg-Tuple{Markdown.MD, Any, Any}"><code>SWCForecast.copyimg</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Copy images that are referenced in the markdown script <code>md</code> to destinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L586-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.copysections-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any, Function}" href="#SWCForecast.copysections-Tuple{AbstractString, Union{Regex, Vector{&lt;:AbstractString}}, Any, Function}"><code>SWCForecast.copysections</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>copysections(headerstr::AbstractString, strvec::Union{Vector{&lt;:AbstractString}, Regex}, result_dir, presentationdir::Function; fnameexpr=expr_defaultmdname, oneslide=false, renameheader=&quot;&quot;, appendhash=false)</code> reads <code>&quot;brief_report.md&quot;</code> file in the target folders whose folder name matches <code>strvec</code>, and returns a vector <code>Markdown.MD</code> objects whose url for local images are relocated. This function is intended to return a vector of <code>Markdown.MD</code> objects with each element being one &quot;slide&quot; for <a href="https://github.com/gnab/remark">Remark.js</a>.</p><p>Noted that all images references by target files (those who name <code>&quot;brief_report.md&quot;</code>) are copied to <code>presentationdir(&quot;src&quot;, &quot;assets&quot;, &quot;img&quot;)</code>, and the referenced paths to the images are relocated to <code>&quot;assets/img/...&quot;</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>oneslide</code>: <code>strvec</code> given as regular expression, only the first slide is returned if <code>oneslide=true</code>. This is useful when the target section <code>headerstr</code> of all files in <code>result_dir</code> is roughly identical.</li><li><code>renameheader</code>: Set <code>md.content[1].text</code> as <code>renameheader</code>. For example, <code>, renameheader=[&quot;Hello &quot;, Markdown.Bold([&quot;World&quot;])]</code></li></ul><p><strong>Example</strong></p><p>Get the &quot;Brief summary&quot; sections in the markdown files <code>&quot;brief_report.md&quot;</code> across all <code>r&quot;RESULT&quot;</code> folders, concatenated as slides (separated by <code>---</code>):</p><pre><code class="language-julia">headerstr = &quot;## Brief Summary&quot;
folderpattern = r&quot;RESULT&quot;
mds = copysections(headerstr, folderpattern, result_dir, presentationdir; fnameexpr=&quot;brief_report.md&quot;) |&gt; join</code></pre><p>A Literate example (one slide); the <code>oneslide=true</code> option returns only the first.</p><pre><code class="language-julia"># ---
# ## Description

headerstr = &quot;### Features&quot; #hide
copysections(headerstr, r&quot;RESULT&quot;, result_dir, presentationdir;oneslide=true)[1] #hide

# ---</code></pre><p>A Literate example that returns slides, where there are total two slides with each page having the <code>&quot;### Data overview&quot;</code> and <code>&quot;### Prediction&quot;</code> sections:</p><pre><code class="language-julia"># ---

strvec = [&quot;052c&quot;, &quot;9a2c&quot;] #hide
headerstr = &quot;### Data overview&quot; #hide
mds = copysections(headerstr, strvec, resultdir0, presentationdir) #hide
headerstr = &quot;### Prediction&quot; #hide
mds2 = copysections(headerstr, strvec, resultdir0, presentationdir; appendhash=true) #hide
elwmerge!(mds, mds2) #hide
join(mds) #hide

# ---</code></pre><p><strong>Tips</strong></p><ul><li>The usage is similar to <code>compareresult</code>, but returns a vector <code>mds::Vector{Markdown.MD}</code> instead of one combined <code>Markdown.MD</code>. Use <code>join(mds)</code> to combine <code>mds</code> into one single <code>Markdown.MD</code>, separated by <code>&quot;---&quot;</code>.</li><li>Use <code>elwmerge!</code> to combine the results elementwisely; this is useful if you want to have sections combined into one slide.</li><li>Also see <a href="https://github.com/piever/Remark.jl">Remark.jl</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L53-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.cropwhite-Tuple{AbstractString}" href="#SWCForecast.cropwhite-Tuple{AbstractString}"><code>SWCForecast.cropwhite</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the file path <code>filei</code>, <code>cropwhite(filei::AbstractString; padding_w = 0.5, padding_h = 0.2, saveInplace=false)</code> returns the cropped image</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/imgproc/imgcrop.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.datenum-Tuple" href="#SWCForecast.datenum-Tuple"><code>SWCForecast.datenum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>datenum(v...)</code> does <code>datenum(DateTime(v...))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/datenum.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.datenum-Tuple{Dates.DateTime}" href="#SWCForecast.datenum-Tuple{Dates.DateTime}"><code>SWCForecast.datenum</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>datenum(d::Dates.DateTime)</code> converts a Julia DateTime to a MATLAB style DateNumber. Also see: <code>toordinal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/datenum.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector, Dates.DatePeriod}" href="#SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector, Dates.DatePeriod}"><code>SWCForecast.datetimeticks!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Similar to <code>datetimeticks!(ax2, t::Vector{DateTime}, x_a::Vector)</code>, <code>datetimeticks!(ax2, t::Vector{DateTime}, x_a::Vector, tinc::DatePeriod; datestrformat = &quot;yyyy/mm/dd&quot;, modify_fn = identity)</code> return <code>xticks, xticklabels</code> with <code>xticks</code> forced to increase with step <code>tinc</code>, and be modify by function <code>modify_fn</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">datetimeticks!(
    ax2,
    [DateTime(2012,2,5,3,15,0), DateTime(2012,3,5,3,15,0)],
    [0, 1], # `x` for `Makie.plot(x, ...)`
    Day(3); # tick every 3 days
    datestrformat = &quot;yyyy/mm/dd&quot;,
    modify_fn = x -&gt; floor.(x, Day)
)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L27-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector}" href="#SWCForecast.datetimeticks!-Tuple{Any, Vector{Dates.DateTime}, Vector}"><code>SWCForecast.datetimeticks!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>datetimeticks!(ax2, t::Vector{DateTime}, x::Vector; datestrformat = &quot;yyyy/mm/dd&quot;)</code> set x ticks to datestr format. <code>t</code> is the <code>DateTime</code> array that is not supported by Makie, <code>x</code> is a arbitrarily defined series of numbers that corresponds to <code>t</code> for <code>Makie.plot</code>. <code>x</code> and <code>t</code> must be the same length and should be pairwisely mapped.</p><p><strong>Example:</strong></p><pre><code class="language-julia">t = df.datetime
x = Dates.datetime2epochms.(t)
x1 = x .- x[1] # to avoid glitchs in plotting with CairoMakie (due to the too-large values)
y = df.soil_water
CairoMakie.scatter!(ax, x, y, markersize =3)
datetimeticks!(ax2, t,x)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.describeinstr-Tuple{Any}" href="#SWCForecast.describeinstr-Tuple{Any}"><code>SWCForecast.describeinstr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given either <code>missing</code>, <code>NaN</code> and <code>Number</code>, returns &quot;Missing&quot;, &quot;Not a Number&quot; and &quot;Number&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{AbstractDescription, AbstractString}" href="#SWCForecast.description!-Tuple{AbstractDescription, AbstractString}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>description!(DDT::AbstractDescription, str::AbstractString)</code> update <code>D.description</code> with string <code>str</code> merged to it.</p><p><strong>Example</strong></p><pre><code class="language-julia">str = &quot;
    [database]
    server = &quot;192.168.1.1&quot;
    ports = [ 8001, 8001, 8002 ]
    &quot;;
description!(DDT, str::AbstractString)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{AbstractDescription, Dict}" href="#SWCForecast.description!-Tuple{AbstractDescription, Dict}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>description!(D::AbstractDescription, d::Dict)</code> update <code>D.description</code> with <code>d</code> merged to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{DescriptCompTree, MLJBase.Machine}" href="#SWCForecast.description!-Tuple{DescriptCompTree, MLJBase.Machine}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the training machine <code>mach</code>, <code>description!(DDT::DescriptCompTree, mach::Machine)</code> update <code>DDT.description</code> with model information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L98-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{DescriptEnsembleTrees, MLJBase.Machine}" href="#SWCForecast.description!-Tuple{DescriptEnsembleTrees, MLJBase.Machine}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the training machine <code>mach</code>, <code>description!(DDT::DescriptEnsembleTrees, mach::Machine)</code> update <code>DDT.description</code> with model information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L171-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{DescriptOneForest, MLJBase.Machine}" href="#SWCForecast.description!-Tuple{DescriptOneForest, MLJBase.Machine}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the training machine <code>mach</code>, <code>description!(DDT::DescriptOneForest, mach::Machine)</code> update <code>DDT.description</code> with model information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L140-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.description!-Tuple{DescriptOneTree, MLJBase.Machine}" href="#SWCForecast.description!-Tuple{DescriptOneTree, MLJBase.Machine}"><code>SWCForecast.description!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the training machine <code>mach</code>, <code>description!(DDT::DescriptOneTree, mach::Machine)</code> update <code>DDT.description</code> with model information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.dict2mdliststr-Tuple{Any}" href="#SWCForecast.dict2mdliststr-Tuple{Any}"><code>SWCForecast.dict2mdliststr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example</strong></p><pre><code class="language-julia">fitp = fitted_params(mach)
best_fitted_param_model = fitp.best_fitted_params.model # which should be a `Dict`

dict2mdliststr(best_fitted_param_model)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L201-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.diffsstable!-Tuple{DataFrames.DataFrame, Any, Any}" href="#SWCForecast.diffsstable!-Tuple{DataFrames.DataFrame, Any, Any}"><code>SWCForecast.diffsstable!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Of a variable of name <code>varnm</code>, <code>diffsstable!(X0::DataFrame, varnm, tshift)</code> calculates the difference between the non-shifted (suffixed by &quot;_t0&quot;) and time-shifted (e.g., &quot;_t-6&quot;), where the difference is the new column for the series-to-supervised table <code>X0</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">    (X0,) = series2supervised(...)
    diffsstable!(X0, &quot;precipitation_1hr&quot;, -6)</code></pre><p>that creates a new column <code>diff6_precipitation_1hr = X0[:, &quot;precipitation_1hr_t0&quot;] .- X0[:, &quot;precipitation_1hr_t-6&quot;]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/series2supervised.jl#L87-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.dropmissingcol-Tuple{Any}" href="#SWCForecast.dropmissingcol-Tuple{Any}"><code>SWCForecast.dropmissingcol</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>dropmissingcol(df)</code> drops columns which are all missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L186-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.elwmerge!-Tuple{Vector{Markdown.MD}, Vector{Markdown.MD}}" href="#SWCForecast.elwmerge!-Tuple{Vector{Markdown.MD}, Vector{Markdown.MD}}"><code>SWCForecast.elwmerge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Merge <code>mds1</code> and <code>mds2</code> elementwisely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L145-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.emptyMD-Tuple{}" href="#SWCForecast.emptyMD-Tuple{}"><code>SWCForecast.emptyMD</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Simply return a empty <code>Markdown.MD</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L150-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.expandylim!-Tuple{Any, Any}" href="#SWCForecast.expandylim!-Tuple{Any, Any}"><code>SWCForecast.expandylim!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>expandylim!(ax, upper_expand)</code> expand the upper limit of y axis to a ratio of <code>upper_expand</code> of the original y range (<code>ymax - ymin</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia">expandylim!(ax, 0.25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.feature_summary-Tuple{Any, Any}" href="#SWCForecast.feature_summary-Tuple{Any, Any}"><code>SWCForecast.feature_summary</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example</strong></p><pre><code class="language-julia">DDTdescript = readdescription(path2toml)
feats0 = DDTdescript[&quot;Model&quot;][&quot;features&quot;]
targs0 = DDTdescript[&quot;Model&quot;][&quot;targets&quot;]
list_features, list_targets = feature_summary(feats0, targs0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/feature_summary.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.feature_summary-Tuple{Any}" href="#SWCForecast.feature_summary-Tuple{Any}"><code>SWCForecast.feature_summary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feats0 = [
&quot;pressure_CWB_t0&quot; ,
&quot;pressure_CWB_t-2&quot; ,
&quot;pressure_CWB_t-4&quot; ,
&quot;pressure_CWB_t-6&quot; ,
&quot;pressure_CWB_t-12&quot; ,
&quot;humidity_CWB_t0&quot; ,
&quot;humidity_CWB_t-2&quot; ,
&quot;humidity_CWB_t-4&quot; ,
&quot;humidity_CWB_t-6&quot; ,
&quot;humidity_CWB_t-12&quot; ,
]</code></pre><pre><code class="language-julia-repl">julia&gt; feature_summary(feats0)
&quot;- pressure CWB ($t_i, i=-12,-6,...,0$; total 5 variables) 
 - humidity CWB ($t_i, i=-12,-6,...,0$; total 5 variables)&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/feature_summary.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.featureselectbyheadkey-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}}} where T&lt;:AbstractString" href="#SWCForecast.featureselectbyheadkey-Union{Tuple{T}, Tuple{Any, Array{Vector{T}, 1}}} where T&lt;:AbstractString"><code>SWCForecast.featureselectbyheadkey</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given feature names of the original table (before time shifted), <code>featureselectbyheadkey(Xtrain, featsets0)</code> returns the table where only variables with column name matches <code>headkey_set</code> in <code>featsets0</code> are preserved. Noted that <code>headkey</code> in <code>headkey_set</code> must be the first keyword of the column name.</p><p><strong>Example</strong></p><pre><code class="language-julia">Xtrain = DataFrame(
    &quot;tmp&quot; =&gt; randn(10),
    &quot;tmp_t0&quot; =&gt; randn(10),
    &quot;tmp_t-1&quot; =&gt; randn(10),
    &quot;humidity&quot; =&gt; randn(10),
    &quot;humidity_t0&quot; =&gt; randn(10),
    &quot;pressure_t0&quot; =&gt; randn(10),
    &quot;pressure_t1&quot; =&gt; randn(10),
)

featsets0 = [
    [:tmp, :humidity],
    [:tmp, :pressure],
    # comma is required even when there is only one union
]</code></pre><p>and</p><pre><code class="language-julia-repl">julia&gt; featureselectbyheadkey(Xtrain, featsets0)
2-element Vector{Vector{Symbol}}:
 [:tmp, :tmp_t0, Symbol(&quot;tmp_t-1&quot;), :humidity, :humidity_t0]
 [:tmp, :tmp_t0, Symbol(&quot;tmp_t-1&quot;), :pressure_t0, :pressure_t1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/featureselect.jl#L11-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.filecolumnview-Tuple{Any}" href="#SWCForecast.filecolumnview-Tuple{Any}"><code>SWCForecast.filecolumnview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Providing the <code>paths</code> to csv files, <code>filecolumnview(paths)</code> gives a plot indicating the available columns of each file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/filecolumnview.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.filecolumnview-Tuple{Regex, Any}" href="#SWCForecast.filecolumnview-Tuple{Regex, Any}"><code>SWCForecast.filecolumnview</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a directory <code>dir</code>, <code>filecolumnview(fexpr::Regex, dir)</code> gives a plot indicating the available columns in files under <code>dir</code> that matches <code>fexpr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/filecolumnview.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.findtrees-Tuple{Vector{MLJBase.Machine}}" href="#SWCForecast.findtrees-Tuple{Vector{MLJBase.Machine}}"><code>SWCForecast.findtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of machines, <code>findtrees(machs::Vector{Machine})</code> returns a vector of only <code>Machine{DecisionTreeRegressor, ...}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L180-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.forcontourf-Tuple{Vector, Vector, Any, Any}" href="#SWCForecast.forcontourf-Tuple{Vector, Vector, Any, Any}"><code>SWCForecast.forcontourf</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>forcontourf(allx::Vector, ally::Vector, xedges, yedges)</code> returns <code>xs, ys, zs</code> for <code>CairoMakie.contourf!(xs, ys, zs)</code>.</p><p>Noted that <code>length(xs) + 1</code> = <code>length(xedges)</code>.</p><p><strong>Input argument</strong></p><ul><li><code>allx</code>, <code>ally</code> are each a vector of values corrsponding to the X and Y coordinates in the plot, indicating all points on the X-Y plane.</li><li><code>xedges</code>, <code>yedges</code> are each a range specifying the edges for calculating 2D histogram.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/histcontour.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.format_time_tag-Tuple{Vector{&lt;:AbstractString}}" href="#SWCForecast.format_time_tag-Tuple{Vector{&lt;:AbstractString}}"><code>SWCForecast.format_time_tag</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>format_time_tag</code> format time tag into LaTeX maths.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; format_time_tag([&quot;t-1&quot;, &quot;t-2&quot;, &quot;t-3&quot;, &quot;t-4&quot;])
&quot;t_{i=-4,-3,...,-1}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/format_time_tag.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.formatcolumn-Tuple{DataFrames.DataFrame}" href="#SWCForecast.formatcolumn-Tuple{DataFrames.DataFrame}"><code>SWCForecast.formatcolumn</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Format <code>DataFrame</code>&#39;s column if the element type belongs <code>AbstractString</code>:</p><ul><li>add &quot;\text{}&quot;</li><li>add &quot;\&quot; to any dash (<code>&quot;_&quot; =&gt; &quot;\_&quot;</code>) to prevent error in the LaTeX building stage</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/latextools.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.generatemyslide-Tuple{Any}" href="#SWCForecast.generatemyslide-Tuple{Any}"><code>SWCForecast.generatemyslide</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Similar to <code>Remark.generate(target_dir)</code>, <code>generatemyslide(target_dir)</code> generate the slide in the folder <code>target_dir</code> but with my template <code>index.jl</code> and <code>style.css</code>.</p><p><strong>Tips and Tricks</strong></p><ul><li>set image width in <code>&quot;src/style.css&quot;</code> at <code>img {max-width: ...}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/slideshow.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.get1var-Tuple{DataFrames.DataFrame, Union{Regex, InvertedIndices.InvertedIndex}}" href="#SWCForecast.get1var-Tuple{DataFrames.DataFrame, Union{Regex, InvertedIndices.InvertedIndex}}"><code>SWCForecast.get1var</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get1var(df::DataFrame, expr::Regex)</code> indexes <code>df</code> on the only one column that matches <code>expr</code>. If more than one columns are matched, it raises an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L151-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.get1var-Tuple{DataFrames.DataFrame}" href="#SWCForecast.get1var-Tuple{DataFrames.DataFrame}"><code>SWCForecast.get1var</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get1var(df::DataFrame)</code> returns the only one column of <code>df</code> as a <code>Vector</code>. If there are more than one column, it raises an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L163-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.get1var-Tuple{Vector}" href="#SWCForecast.get1var-Tuple{Vector}"><code>SWCForecast.get1var</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get1var(v::Vector)</code> get the only variable in the vector <code>v</code> which should have exactly one element; an error will be raised if <code>length(v) != 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L175-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.getallfeat-Tuple{AbstractString}" href="#SWCForecast.getallfeat-Tuple{AbstractString}"><code>SWCForecast.getallfeat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get all features (a vector of column names).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/filecolumnview.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.getallfeat-Tuple{Vector}" href="#SWCForecast.getallfeat-Tuple{Vector}"><code>SWCForecast.getallfeat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get all features (column names). Returns file names (<code>ks</code>) and columnames of each file (<code>vls</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/filecolumnview.jl#L69-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.getparam_atom-Tuple{MLJBase.Machine}" href="#SWCForecast.getparam_atom-Tuple{MLJBase.Machine}"><code>SWCForecast.getparam_atom</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Retrieve the atom model and learned parameters for each atoms</p><pre><code class="language-julia">all_machs = fitted_params(mach).machines
findparam(mach::Machine{T, N}) where {T, N} = T

tps = all_machs .|&gt; findparam # datatypes
targetmodelnamepattern = r&quot;MLJ.*DecisionTreeRegressor&quot;
# which matches:
# &quot;MLJEnsembles.DeterministicEnsembleModel{DecisionTreeRegressor}&quot;
# &quot;MLJTuning.DeterministicTunedModel{RandomSearch, MLJEnsembles.DeterministicEnsembleModel{DecisionTreeRegressor}}&quot;
idisforest = occursin.(targetmodelnamepattern, string.(tps))
forests_trained = all_machs[idisforest]


atomeachforest = getmodel_atom.(forests_trained)
parameachforest = getparam_atom.(forests_trained)
# [f.fitresult.fitresult.atom for f in forests_trained]

treemodels = []
treestructs = []
for (atom, treestruct) in zip(atomeachforest, parameachforest)
    push!(treestructs, treestruct)
    push!(treemodels, fill(atom, length(treestruct)))
end

learnedparams_tree = vcat(treestructs...)
atoms = vcat(treemodels...)
ntrees = length(learnedparams_tree)
# 1st model is TunedModel; 2nd is EnsembleModel</code></pre><p>Also see</p><ul><li>[7] <code>build_forest(labels::AbstractVector{T}, features::AbstractMatrix{S}, n_subfeatures, n_trees, partial_sampling, max_depth, min_samples_leaf, min_samples_split) where {S, T&lt;:Float64}</code> in DecisionTree at /.../DecisionTree/iWCbW/src/regression/main.jl:49</li><li><code>fit!(rf::RandomForestRegressor, X::AbstractMatrix, y::AbstractVector)</code> at /.../DecisionTree/iWCbW/src/scikitlearnAPI.jl:300</li><li><code>WrappedEnsemble(atom, ensemble::AbstractVector{L}) where L</code> at /.../MLJEnsembles/OsgHR/src/ensembles.jl</li><li><code>MMI.fitted_params(::RandomForestRegressor, forest) = (forest=forest,)</code> and</li><li><code>MMI.predict(::RandomForestRegressor, forest, Xnew)</code> at /.../MLJDecisionTreeInterface/CtTJy/src/MLJDecisionTreeInterface.jl:255</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/get_fitresult.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.getsection-Tuple{AbstractString, Any}" href="#SWCForecast.getsection-Tuple{AbstractString, Any}"><code>SWCForecast.getsection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Give the path of the markdown file, returns a <code>Markdown.MD</code> object of the section <code>headerstr</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">path = &quot;/training/brief_report.md&quot;
headerstr = &quot;## Description&quot;
getsection(path, headerstr)</code></pre><p>In this example, the section starts from &quot;## Description&quot; and ends right before the next level 2 (e.g., &quot;## blablabla&quot;) or level 1 (e.g., &quot;# blabla&quot;) header; comments in code fences won&#39;t be recognized as a header.</p><p>Also see <code>SubMD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L246-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.getxylimits-Tuple{Any}" href="#SWCForecast.getxylimits-Tuple{Any}"><code>SWCForecast.getxylimits</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example</strong></p><pre><code class="language-julia">xmin, ymin, xmax, ymax = getxylimits(ax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.group_feature-Tuple{Any}" href="#SWCForecast.group_feature-Tuple{Any}"><code>SWCForecast.group_feature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of string <code>str0</code> with each element being like <code>&quot;r_o_o_t_suffix&quot;</code>, <code>group_feature(str0)</code> returns an Iterator with each a subgroup of elements having the same root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/feature_summary.jl#L78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.ifstrparse-Tuple{Any, Any}" href="#SWCForecast.ifstrparse-Tuple{Any, Any}"><code>SWCForecast.ifstrparse</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ifstrparse(x, TYPE)</code>: if <code>x</code> is <code>AbstractString</code>, then parse it to the variable of <code>TYPE</code>, ignoring <code>NaN</code> and <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.imputemean!-Tuple{Any}" href="#SWCForecast.imputemean!-Tuple{Any}"><code>SWCForecast.imputemean!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>imputemean!(df)</code> substitute missing values with the statistical means. If all missing for a column, value <code>999</code> is imputed.</p><p><strong>Notice</strong></p><ul><li>You should be aware that <code>imputemean!</code> might does nothing without error message if the input is a view of dataframe (e.g., df[!, Not(:datetime)]).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myimputation/myimpute.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.isableparse-Tuple{Any, Any}" href="#SWCForecast.isableparse-Tuple{Any, Any}"><code>SWCForecast.isableparse</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isableparse(x, TYPE)</code> use <code>try...catch</code> to check if <code>x</code> can be parsed to of <code>TYPE</code>. If not, return <code>x</code>; else, return <code>TYPE</code>. If <code>x::TYPE</code> it also returns <code>TYPE</code> evenif it can&#39;t be parsed to the type of itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.iscommented-Tuple{AbstractString}" href="#SWCForecast.iscommented-Tuple{AbstractString}"><code>SWCForecast.iscommented</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>iscommented(oneline::AbstractString)</code> returns <code>true</code> if the line is commented by <code>&quot;#&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.iscommentedand-Tuple{AbstractString, Any}" href="#SWCForecast.iscommentedand-Tuple{AbstractString, Any}"><code>SWCForecast.iscommentedand</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>iscommentedand(oneline::AbstractString, tag)</code> returns <code>true</code> if the line is commented and starts with <code>tag</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.islevel-Tuple{Any, Any}" href="#SWCForecast.islevel-Tuple{Any, Any}"><code>SWCForecast.islevel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a object <code>mdc</code>, <code>islevel(mdc, n)</code> returns true if <code>mdc</code> is the type of <code>Markdown.Header{n}</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L179-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.islevelleq-Tuple{Any, Any}" href="#SWCForecast.islevelleq-Tuple{Any, Any}"><code>SWCForecast.islevelleq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a object <code>mdc</code>, <code>islevelleq(mdc, n)</code> returns true if <code>mdc</code> is the type of <code>Markdown.Header{x}</code> where <code>x ≤ n</code>. In brief, it recursively finds if it is a header of higher level (smaller <code>n</code>) until <code>n==0</code> (<code>false</code> is returned).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L186-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.isvarexist-Tuple{Any}" href="#SWCForecast.isvarexist-Tuple{Any}"><code>SWCForecast.isvarexist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isvarexist(paths)</code> returns dataframes <code>(df1, df2)</code> in the &quot;long&quot; format with each row indicating whether a variable in a file exists. In which, <code>(df, dfi)</code> both have columns <code>[:varname, :fname, :isexist]</code>. In <code>df</code>, all variables are <code>CategoricalArray</code>s; in <code>dfi</code>, all variables are integers for indexing <code>levels(df.varname)</code>, <code>levels(df.fname)</code> and <code>levels(df.isexist)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/filecolumnview.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.iswhite-Tuple{ColorTypes.RGBA}" href="#SWCForecast.iswhite-Tuple{ColorTypes.RGBA}"><code>SWCForecast.iswhite</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Check if the pixel is white or transparent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/imgproc/imgcrop.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.latextable-Tuple{DataFrames.DataFrame, MIME{Symbol(&quot;text/latex&quot;)}}" href="#SWCForecast.latextable-Tuple{DataFrames.DataFrame, MIME{Symbol(&quot;text/latex&quot;)}}"><code>SWCForecast.latextable</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>latextable(dftmp, MIME(&quot;text/latex&quot;))</code> returns a very simple latex table that applies <code>MIME(&quot;text/latex&quot;)</code>. Other <code>MIME</code> is of-coursely unsupported. This method is experimental following <a href="https://medium.com/chifi-media/mimes-in-julia-what-are-they-d9af13c3ed96">Mimes In Julia: What Are They?</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/latextools.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.latextable-Tuple{Vector{InfoShiftedFeature}}" href="#SWCForecast.latextable-Tuple{Vector{InfoShiftedFeature}}"><code>SWCForecast.latextable</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Other Support:</strong></p><pre><code class="language-none">ISFs = [InfoShiftedFeature(gf) for gf in group_feature(names(X0))]
latextable(ISFs::Vector{InfoShiftedFeature})</code></pre><p>which is equivalent to</p><pre><code class="language-julia">dftmp = DataFrame(&quot;feature name&quot; =&gt; String[], &quot;time shift&quot; =&gt; String[])
for ISF1 in ISFs
    push!(dftmp, [ISF1.root, join(string.(ISF1.timeshift), &quot; ,&quot;)])
end
latextable(dftmp::DataFrame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/latextools.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.latextable-Tuple{Vector{Pair{String, DataFrames.DataFrame}}}" href="#SWCForecast.latextable-Tuple{Vector{Pair{String, DataFrames.DataFrame}}}"><code>SWCForecast.latextable</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>latextable(manytables::Vector{Pair{String,DataFrame}})</code> is under construction. Noted that</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/latextools.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.level_text-Tuple{Any}" href="#SWCForecast.level_text-Tuple{Any}"><code>SWCForecast.level_text</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example</strong></p><p><code>level_text(&quot;## Introduction&quot;)</code> returns the header level and the appending string <code>(2, &quot;Introduction&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L267-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.load_decision_tree_regressor-Tuple{}" href="#SWCForecast.load_decision_tree_regressor-Tuple{}"><code>SWCForecast.load_decision_tree_regressor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_decision_tree_regressor(; package=&quot;DecisionTree&quot;, kwargs...)</code></pre><p>A wrapper function for <code>MLJ</code> @load macro that returns a <code>DecisionTreeRegressor</code> object.</p><p><strong>Keywords</strong></p><ul><li><code>package::AbstractString=&quot;DecisionTree&quot;</code>: Package that provides <code>DecisionTreeRegressor</code>,   which now has [&quot;DecisionTree&quot;, &quot;BetaML&quot;] to choose from</li><li><code>kwargs</code>: Valid hyperparameters of <code>DecisionTreeRegressor</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/utils/models.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.manyscript-Tuple{Any, Vararg{Pair}}" href="#SWCForecast.manyscript-Tuple{Any, Vararg{Pair}}"><code>SWCForecast.manyscript</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>manyscript(path_to_script0, ind_expr_newstrs::Pair...; append_info = false)</code> creates a new script where the patterns in target lines are replaced by new <code>String</code>s or <code>SubstitutionString</code>s.</p><p>This function never overwrite old files; see also <code>pathnorepeat</code>.</p><p>If <code>append_info = true</code>, summary of the modified changes will be appended at the end of the new file.</p><p><strong>Example</strong></p><pre><code class="language-julia">for mm = 1:12 # test training/predicting timescale
    ind_expr_newstr = [66 =&gt; r&quot;\d+&quot; =&gt; &quot;1.0mm&quot;,
                        81 =&gt; r&quot;tpast = \d+&quot; =&gt; &quot;tpast = 12&quot;,
                        81 =&gt; r&quot;tfuture = \d+&quot; =&gt; &quot;tfuture = 2&quot;,
                        All() =&gt; r&quot;includet&quot; =&gt; &quot;include&quot;] # replace all &quot;includet&quot; by &quot;include&quot;. The regular expression can match text across lines.
    manyscript(path_to_script0, ind_expr_newstr...)
end</code></pre><p><strong>Tips and Tricks</strong></p><p><strong>Comment or uncomment a certain line</strong></p><pre><code class="language-julia">ind_expr_newstr = [
    66 =&gt; r&quot;^#\s*&quot; =&gt; &quot;&quot;, # uncomment line 66
    77 =&gt; r&quot;(^.)&quot; =&gt; s&quot;# \1&quot;, # comment line 77
    All() =&gt; r&quot;includet&quot; =&gt; &quot;include&quot; # replace all &quot;includet&quot; by &quot;include&quot;. In this case the regular expression matches text across lines.
    ]
manyscript(path_to_script0, ind_expr_newstr...)</code></pre><p>Also see <code>reline!</code> and <code>replace</code>.</p><p><strong>Use regular expression to find the line for replacement</strong></p><p>For <code>ind_expr_newstr</code> pair, if <code>ind</code> is regular expression, then it searches the only line with that matches the pattern. e.g.,</p><pre><code class="language-julia">ind_expr_newstr = [All() =&gt; r&quot;includet&quot; =&gt; &quot;include&quot;,
                r&quot;# run month by month&quot; =&gt; r&quot;^#\s*&quot; =&gt; &quot;&quot;, # uncommentat the line
                r&quot;# run month by month&quot; =&gt; r&quot;\d+&quot; =&gt; &quot;1.0mm&quot; # `reline!` on the line having the comment &quot;# run month by month&quot;
                ]
manyscript(path_to_script0, ind_expr_newstr...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.markdownreport-Tuple{AbstractDescription}" href="#SWCForecast.markdownreport-Tuple{AbstractDescription}"><code>SWCForecast.markdownreport</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>markdownreport(DDT::AbstractDescription)</code> <code>Literate</code> the corresponding template in <code>mdtemplatedir()</code> generating the markdown report with all variables (informations) loaded from <code>DDT.description_dir(&quot;description.toml&quot;)</code>. It automatically loads <code>&quot;tmpl_$typeofDDT.jl&quot;</code> where <code>typeofDDT</code> is the type of <code>DDT</code>.</p><p>Also see <code>description</code>, <code>descrption!</code>, <code>readdescription</code>, <code>writedescription</code> for processing <code>&quot;description.toml&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.markdownreport-Tuple{Any, Any, Any}" href="#SWCForecast.markdownreport-Tuple{Any, Any, Any}"><code>SWCForecast.markdownreport</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>markdownreport(path2toml, path2template, mdreport_dir)</code> <code>Literate</code> the corresponding template <code>path2template</code> generating the markdown report with all variables (informations) loaded from <code>path2toml</code>. The output markdown file is saved in <code>mdreport_dir</code>.</p><p>In your template (e.g., <code>&quot;tmpl_XXXXXX.jl&quot;</code> in <code>mdtemplatedir</code>), string <code>&quot;PATH2TOML&quot;</code> will be replaced by the variable <code>path2toml</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.markdownreport-Tuple{Any, Any}" href="#SWCForecast.markdownreport-Tuple{Any, Any}"><code>SWCForecast.markdownreport</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example</strong></p><pre><code class="language-julia">templatename = &quot;tmpl_DescriptOneTree.jl&quot;
result_dir = &quot;/home/jovyan/swc-forecast-insider/training/decisiontree_20220330/my_result_0000&quot;
markdownreport(templatename, result_dir; findin=r&quot;RESULT&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdimgpath!-Tuple{Markdown.Image, AbstractString}" href="#SWCForecast.mdimgpath!-Tuple{Markdown.Image, AbstractString}"><code>SWCForecast.mdimgpath!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdimgpath!(mdimg::Markdown.Image, dirnm)</code> modify <code>mdimg.url</code> that <code>mdimg.url = joinpath(dirnm, mdimg.url)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L494-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdimgpath!-Tuple{Markdown.Image, Function}" href="#SWCForecast.mdimgpath!-Tuple{Markdown.Image, Function}"><code>SWCForecast.mdimgpath!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdimgpath!(mdimg::Markdown.Image, dirfun::Function)</code> modify <code>mdimg.url</code> that <code>mdimg.url = dirfun(mdimg.url)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">thatresultdir(args...) = joinpath(&quot;foo&quot;, &quot;bar&quot;, args...)
md1 = md&quot;&quot;&quot;
# Hello
this is a image:
![](foobar.png)
&quot;&quot;&quot;

mdimgpath!(md1.content, thatresultdir)
</code></pre><p>returns</p><pre><code class="language-none">md1 = md&quot;&quot;&quot;
# Hello
this is a image:
![](foo/bar/foobar.png)
&quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L502-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdimgpath!-Tuple{Markdown.MD, Any}" href="#SWCForecast.mdimgpath!-Tuple{Markdown.MD, Any}"><code>SWCForecast.mdimgpath!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdimgpath!(md::Markdown.MD, dirnm) = mdimgpath!(md.content, dirnm)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L543-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdimgpath!-Tuple{SubMD, Any}" href="#SWCForecast.mdimgpath!-Tuple{SubMD, Any}"><code>SWCForecast.mdimgpath!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdimgpath!(smd::SubMD, dirnm) = mdimgpath!(smd.md.content, dirnm)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L536-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdimgpath!-Tuple{Vector, Any}" href="#SWCForecast.mdimgpath!-Tuple{Vector, Any}"><code>SWCForecast.mdimgpath!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of Markdown contents <code>mdc</code>, <code>mdimgpath!(mdc::Vector, dirnm)</code> recursively searches <code>Markdown.Image</code> object and join the url (<code>Markdown.Image.url</code>) with <code>dirnm</code> (e.g., ).</p><p><strong>Example</strong></p><p>Before:</p><pre><code class="language-julia">6-element Vector{Any}:
 Markdown.Header{2}(Any[&quot;Result&quot;])
 Markdown.Header{3}(Any[&quot;Performance－Tree Depth&quot;])
 Markdown.Paragraph(Any[Markdown.Image(&quot;tuned_max_depth.png&quot;, &quot;&quot;)])
 Markdown.Header{3}(Any[&quot;Predict Result&quot;])
 Markdown.List(Any[Any[Markdown.Paragraph(Any[&quot;Best maximum depth is 33.&quot;])]], -1, false)
 Markdown.Paragraph(Any[Markdown.Image(&quot;predict_result.png&quot;, &quot;&quot;)])</code></pre><p>Change the url:</p><pre><code class="language-julia">julia&gt; mdimgpath!(md.content, &quot;RESULT_ExpeDeci_0x15b03b01222fec37&quot;)</code></pre><p>After:</p><pre><code class="language-julia">
julia&gt; md.content
6-element Vector{Any}:
 Markdown.Header{2}(Any[&quot;Result&quot;])
 Markdown.Header{3}(Any[&quot;Performance－Tree Depth&quot;])
 Markdown.Paragraph(Any[Markdown.Image(&quot;RESULT_ExpeDeci_0x15b03b01222fec37/tuned_max_depth.png&quot;, &quot;&quot;)])
 Markdown.Header{3}(Any[&quot;Predict Result&quot;])
 Markdown.List(Any[Any[Markdown.Paragraph(Any[&quot;Best maximum depth is 33.&quot;])]], -1, false)
 Markdown.Paragraph(Any[Markdown.Image(&quot;RESULT_ExpeDeci_0x15b03b01222fec37/predict_result.png&quot;, &quot;&quot;)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L453-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdpaths-Tuple{Any, Regex, Any}" href="#SWCForecast.mdpaths-Tuple{Any, Regex, Any}"><code>SWCForecast.mdpaths</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdpaths(fnameexpr, fldrexpr::Regex, this_dir)</code> returns a list of paths to the markdown files who matches <code>fnameexpr</code>. It searches only the markdown files in the folders in <code>this_dir</code> whose name matches <code>fldrexpr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L369-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdpaths-Tuple{Any, Vector, Any}" href="#SWCForecast.mdpaths-Tuple{Any, Vector, Any}"><code>SWCForecast.mdpaths</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mdpaths(fnameexpr::Regex, strvec::Vector, this_dir::AbstractString)</code> is a shorthand to get the paths to target markdown files.</p><p><strong>Example</strong></p><pre><code class="language-julia">this_dir= &quot;/training/decisiontree_20220309/&quot;
fnameexpr = r&quot;brief\_report\.md&quot;
strvec = [&quot;ac23&quot;, &quot;7df6&quot;, &quot;ddf&quot;, &quot;c37&quot;]

mdpaths(fnameexpr, strvec, this_dir)</code></pre><p>which returns</p><pre><code class="language-none">4-element Vector{String}:
    &quot;/training/decisiontree_20220309/RESULT_ExpeDeci_0x15b03b01222fec37/brief_report.md&quot;
    &quot;/training/decisiontree_20220309/RESULT_ExpeDeci_0x8a37ffc85c22eddf/brief_report.md&quot;
    &quot;/training/decisiontree_20220309/RESULT_ExpeDeci_0xa14053903286ac23/brief_report.md&quot;
    &quot;/training/decisiontree_20220309/RESULT_ExpeDeci_0xd8a362b941617df6/brief_report.md&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L341-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mdreport-Tuple{DescriptOneTree, Any}" href="#SWCForecast.mdreport-Tuple{DescriptOneTree, Any}"><code>SWCForecast.mdreport</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(DEPRECATED: use <code>generatemyreport</code> instead)</p><p><code>mdreport(DDT::DescriptOneTree, scriptpath)</code> gives the report in juliamarkdown for script (<code>scriptpath</code>) based on results (<code>DDT.description</code>). The output folder is <code>DDT.description_dir(&quot;brief_report.md&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/mdreport.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mkresultdir-Tuple{Any}" href="#SWCForecast.mkresultdir-Tuple{Any}"><code>SWCForecast.mkresultdir</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the path to the script file <code>exp_file</code>, <code>mkresultdir</code> return the path to the new directory named with the hash value of the file. That is, once <code>exp_file</code> has been changed, a new directory will be created with its path returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/mkresultdir.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mvmean-Tuple{Any, Any}" href="#SWCForecast.mvmean-Tuple{Any, Any}"><code>SWCForecast.mvmean</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mvmean(arr, n)</code> retruns an array of element <code>length(arr) - n</code> of moving averaged results.</p><p>This is the function that performs best on https://stackoverflow.com/questions/59562325/moving-average-in-julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/movingaverage.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mvnanmean-Tuple{Any, Any}" href="#SWCForecast.mvnanmean-Tuple{Any, Any}"><code>SWCForecast.mvnanmean</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mvnanmean(arr, n)</code> use <code>mvmean</code> but ignoring <code>NaN</code>. The output array has the same dimensions as the input one, with the first <code>n - 1</code> element be <code>NaN</code>.</p><p><strong>WARNING</strong></p><p>You may have to do imputation first before calculating moving average because ALL <code>NaN</code> are considered to be 0 when calculating moving average; that is, the average will be zero when all elements in the moving window are all <code>NaN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/movingaverage.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mycolor_makie_palette-Tuple{}" href="#SWCForecast.mycolor_makie_palette-Tuple{}"><code>SWCForecast.mycolor_makie_palette</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mycolor_makie_palette()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/mycolors.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mycolor_plots_palette-Tuple{Any, Any}" href="#SWCForecast.mycolor_plots_palette-Tuple{Any, Any}"><code>SWCForecast.mycolor_plots_palette</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Example:</strong></p><p><code>mycolor_plots_palette(:tab10, 5)</code> which is equivalently <code>Plots.palette(:tab10, 5)</code></p><p><strong>See the following for color schemes:</strong></p><ul><li>https://docs.juliahub.com/MakieGallery/Ql23q/0.2.17/generated/colors.html</li><li>https://docs.juliaplots.org/latest/generated/colorschemes/</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/mycolors.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.mymovwinmean-Tuple{Vector{Float64}, Any}" href="#SWCForecast.mymovwinmean-Tuple{Vector{Float64}, Any}"><code>SWCForecast.mymovwinmean</code></a> — <span class="docstring-category">Method</span></header><section><div><p>my moving average function of poor performance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/movingaverage.jl#L86-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.myslideshow-Tuple{Any}" href="#SWCForecast.myslideshow-Tuple{Any}"><code>SWCForecast.myslideshow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Since currently <code>Remark.slideshow</code> has some problem:</p><ul><li>if <code>documenter=false</code>, code won&#39;t be executed as expected</li><li>if <code>documenter=true</code>, some strings in math equations will be misreplaced</li></ul><p><code>myslideshow(presentation_dir; options=Dict(), title=&quot;Title&quot;)</code> does the following:</p><ul><li>run <code>Remark.slideshow()</code></li><li><code>Literate.markdown</code> with <code>flavor=Literate.CommonMarkFlavor(), execute=true, mdstrings=true, postprocess=hide_section</code></li><li>create <code>index.html</code> again, while other files in <code>&quot;build&quot;</code> left untouched.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">myslideshow(presentation_dir; options = Dict(&quot;ratio&quot; =&gt; &quot;16:9&quot;))</code></pre><p><strong>Tips and Tricks</strong></p><ul><li>you can use <code>#hide-below</code> and <code>#hide-above</code> to hide the entire section</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/slideshow.jl#L195-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.narrow_types!-Tuple{Any}" href="#SWCForecast.narrow_types!-Tuple{Any}"><code>SWCForecast.narrow_types!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">narrow_types!(df)</code></pre><p>Narrows the <code>eltype</code> of each column to the type that actually exists in the each column of dataframe.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: Dataframe for which you want to narrow the <code>eltype</code> of each column</li></ul><p><strong>References</strong></p><p>https://discourse.julialang.org/t/how-to-change-field-names-and-types-of-a-dataframe/43991/9</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/utils/dataframe.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.onlycodelines-Tuple{AFile}" href="#SWCForecast.onlycodelines-Tuple{AFile}"><code>SWCForecast.onlycodelines</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>onlycodelines(script::AbstractString)</code> or <code>onlycodelines(scriptfile::AFile)</code> returns lines that are not commented. See also <code>iscommented</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/markdownreport.jl#L95-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.print2string-Tuple{Any}" href="#SWCForecast.print2string-Tuple{Any}"><code>SWCForecast.print2string</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Praise master ZK! <code>print2string(printfun)</code> print content to memory and take it out as a <code>String</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">printfun() = MLJDecisionTreeInterface.DT.print_tree(
    mach.fitresult.fitresult; feature_names=names(mach.fitresult.data[1]))

print2string(printfun)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/print2string.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.quantileband!-Tuple{Any, Any, Any, Vector{&lt;:Real}, ColorSchemes.ColorScheme}" href="#SWCForecast.quantileband!-Tuple{Any, Any, Any, Vector{&lt;:Real}, ColorSchemes.ColorScheme}"><code>SWCForecast.quantileband!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quantileband!(ax, xhat, ys, percs::Vector{&lt;:Real}, bandcolormap::ColorSchemes.ColorScheme)</code>, where colors are automatically picked from <code>bandcolormap</code> according to <code>percs</code>. It returns <code>(percs, bds)</code> where <code>bd = band!(...)</code>.</p><p>Noted that <code>percs</code> will be sorted that the order does not matter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/multibands.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.quantileband!-Union{Tuple{T}, Tuple{Any, Vector{T}, Array{Vector{T}, 1}, Real, Any}} where T&lt;:Real" href="#SWCForecast.quantileband!-Union{Tuple{T}, Tuple{Any, Vector{T}, Array{Vector{T}, 1}, Real, Any}} where T&lt;:Real"><code>SWCForecast.quantileband!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quantileband!(ax, xhat::Vector{T}, ys::Vector{Vector{T}}, perc::Real, bandcolor) where T&lt;:Real</code> draw a <code>band</code> of <code>perc</code> quantile to <code>ax</code>. The band covers <code>perc</code> of data where <code>0 ≤ perc ≤ 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/multibands.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.quickdataoverview-Tuple{DataFrames.DataFrame}" href="#SWCForecast.quickdataoverview-Tuple{DataFrames.DataFrame}"><code>SWCForecast.quickdataoverview</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>quickdataoverview(df_all::DataFrame; gridwidth=Month(1), xname=:datetime, figsize=(23cm, 12cm))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/plots_recipes/quickplot.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.readdescription!-Tuple{AbstractDescription}" href="#SWCForecast.readdescription!-Tuple{AbstractDescription}"><code>SWCForecast.readdescription!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>readdescription!(D::AbstractDescription)</code> read <code>&quot;description.toml&quot;</code> file and return the nested dictionary (i.e., <code>D.description</code> in <code>writedescription</code>); <code>D.description</code> will be overwritten by the loaded one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L42-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.readdescription-Tuple{AbstractString}" href="#SWCForecast.readdescription-Tuple{AbstractString}"><code>SWCForecast.readdescription</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>readdescription(path2toml::AbstractString)</code> read <code>&quot;description.toml&quot;</code> file and return the nested dictionary (i.e., <code>D.description</code> in <code>writedescription</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.recursive_merge!-Tuple{Vararg{AbstractDict}}" href="#SWCForecast.recursive_merge!-Tuple{Vararg{AbstractDict}}"><code>SWCForecast.recursive_merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <code>recursive_merge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/recursive_merge.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.recursive_merge-Tuple{Vararg{AbstractDict}}" href="#SWCForecast.recursive_merge-Tuple{Vararg{AbstractDict}}"><code>SWCForecast.recursive_merge</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>recursive_merge</code> merges dictionaries combining thier unique key-value pairs together. Similar to <code>merge(d, d1, d2,...)</code>, but <code>recursive_merge</code> merge the dictionary recursively that sub-dictionaries are also merged, while <code>merge(d, d1)</code> replace the sub-dict in <code>d</code> by that in <code>d1</code>. This piece of code originally came from this thread: https://discourse.julialang.org/t/multi-layer-dict-merge/27261/2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/recursive_merge.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.reduce_feature-Tuple{Any}" href="#SWCForecast.reduce_feature-Tuple{Any}"><code>SWCForecast.reduce_feature</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reduce_feature(feats0)</code> returns unique feature names and time tags that are split by <code>split_time_tag</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/feature_summary.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.reducetype-Tuple{AbstractArray}" href="#SWCForecast.reducetype-Tuple{AbstractArray}"><code>SWCForecast.reducetype</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reducetype(v::AbstractArray)</code> returns the array of type <code>Union{uniqueTYPE}</code>, where <code>uniqueTYPE = v .|&gt; typeof |&gt; unique</code>.</p><p>For more about manipulating datatype, also see <code>nonmissingtype</code> in <a href="https://github.com/JuliaLang/julia/blob/master/base/missing.jl">missing.jl</a> and <code>Base.typesplit</code> in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">promotion.jl</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.refbuildpath-Tuple{Any}" href="#SWCForecast.refbuildpath-Tuple{Any}"><code>SWCForecast.refbuildpath</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given <code>abspath</code>, <code>refbuildpath(abspath)</code> returns referenced path relative to the <code>.../build/aseets</code> folder.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; abspath = &quot;/home/jovyan/swc-forecast-insider/temp_ppt/build/assets/img/trees_subset_1/tree_root_1.png&quot;

julia&gt; refbuildpath(abspath)
&quot;assets/img/trees_subset_1/tree_root_1.png&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/slideshow.jl#L267-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.reline!-Tuple{Any, DataAPI.All, Any, AbstractString}" href="#SWCForecast.reline!-Tuple{Any, DataAPI.All, Any, AbstractString}"><code>SWCForecast.reline!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reline!(lines, ind::All, expr, newstr::AbstractString)</code> replace the pattern matched by <code>expr</code> with <code>newstr</code> in the scope of <code>fullscript = join(lines, &quot; &quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.reline!-Tuple{Any, Int64, Union{Regex, AbstractString}, AbstractString}" href="#SWCForecast.reline!-Tuple{Any, Int64, Union{Regex, AbstractString}, AbstractString}"><code>SWCForecast.reline!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reline!(lines, ind::Int, expr::Union{AbstractString, Regex}, newstr::AbstractString)</code> replace string that matches <code>expr</code> in <code>lines[ind]</code> by <code>newstr</code>. <code>newstr</code> can be <code>SubstitutionString</code>. See the documentation of <code>replace</code> and <code>SubstitutionString</code>.</p><p><strong>WARNING: if <code>ind</code> is an integer or <code>ind = All()</code>, no warning or error pops if <code>expr</code> matches nothing such that nothing had changed. Use <code>reline!(lines, expr_findline::Regex, expr_replacecode::Regex, newstr::AbstractString)</code> if you want a warning or an error for non-exclusive matching.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.reline!-Tuple{Any, Regex, Union{Regex, AbstractString}, AbstractString}" href="#SWCForecast.reline!-Tuple{Any, Regex, Union{Regex, AbstractString}, AbstractString}"><code>SWCForecast.reline!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>reline!(lines, expr_findline::Regex, expr_replacecode::Union{AbstractString, Regex}, newstr::AbstractString)</code> replace string that matches <code>expr_replacecode</code> in <code>lines[ind]</code> by <code>newstr</code>, where <code>ind</code> indicates the line whose appending comment matches <code>expr_findline</code>. <code>newstr</code> can be <code>SubstitutionString</code>. See the documentation of <code>replace</code> and <code>SubstitutionString</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.replacerewrite-Tuple{AbstractString, Any, Any}" href="#SWCForecast.replacerewrite-Tuple{AbstractString, Any, Any}"><code>SWCForecast.replacerewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><p>replace certain keyword in the entire script</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L136-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.result_folder_expr-Tuple{Vector{&lt;:AbstractString}}" href="#SWCForecast.result_folder_expr-Tuple{Vector{&lt;:AbstractString}}"><code>SWCForecast.result_folder_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>result_folder_expr(strvec::Vector{&lt;:AbstractString})</code> returns a single regular expression that should capture the directories for machine learning results. For example, <code>result_folder_expr([&quot;ac43&quot;])</code>     <code>&quot;RESULT_...0x...&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.returnchild-Tuple{Markdown.Paragraph}" href="#SWCForecast.returnchild-Tuple{Markdown.Paragraph}"><code>SWCForecast.returnchild</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>returnchild(obj::Markdown.Paragraph)</code>: Given a <code>Markdown.Paragraph</code>, return the vector <code>obj.text</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L558-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.returnchild-Tuple{Union{Markdown.Bold, Markdown.Italic, Markdown.Header}}" href="#SWCForecast.returnchild-Tuple{Union{Markdown.Bold, Markdown.Italic, Markdown.Header}}"><code>SWCForecast.returnchild</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>returnchild(obj)</code>: Given an object <code>obj::Union{Markdown.Italic, Markdown.Bold, Markdown.Header}</code>, return the vector <code>obj.text</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L550-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.runallscript-Tuple{Function}" href="#SWCForecast.runallscript-Tuple{Function}"><code>SWCForecast.runallscript</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Noted that the script to include shares the scope of SWCForecast module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/metascript.jl#L119-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.secondyaxis-Tuple{Any}" href="#SWCForecast.secondyaxis-Tuple{Any}"><code>SWCForecast.secondyaxis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>secondyaxis(f_grid; color = :black, ylabel = &quot;y&quot;)</code> returns an <code>Axis</code> object of y axis to the right-hand side, with default settings for yyplot.</p><p><strong>Example</strong></p><pre><code class="language-julia">f = Figure()
ax_right = secondyaxis(f[1,1]; color=:red)

</code></pre><p>that you can do <code>lines!(ax_right, ...)</code></p><p><strong>Further reading</strong></p><ul><li><a href="https://github.com/JuliaPlots/Makie.jl/issues/816">Is it possible to add a secondary y axis?</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L151-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.selectname-Tuple{DataFrames.DataFrame, Any}" href="#SWCForecast.selectname-Tuple{DataFrames.DataFrame, Any}"><code>SWCForecast.selectname</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>selectname(df::DataFrame, arg)</code> returns a vector of column names that match <code>arg</code> of the dataframe <code>df</code>. <code>arg</code> can be <code>Regex</code>, <code>AbstractString</code>, or <code>InvertedIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L142-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.selectnames-Tuple{Any, Vararg{Any}}" href="#SWCForecast.selectnames-Tuple{Any, Vararg{Any}}"><code>SWCForecast.selectnames</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>selectnames(dfnames, args...)</code> select an array of names that contains <code>arg::String</code> or pattern that matches <code>arg::Regex</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; selectnames([&quot;Soil_water_content_10cm, water_level_#1, water_level_#2&quot;], r&quot;water_lev&quot;)

[water_level_#1, water_level_#2&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/dataframetools.jl#L108-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.series2supervised-Tuple{Vararg{Pair}}" href="#SWCForecast.series2supervised-Tuple{Vararg{Pair}}"><code>SWCForecast.series2supervised</code></a> — <span class="docstring-category">Method</span></header><section><div><p>To transform a time series dataset into a supervised learning dataset</p><p><strong>Example</strong></p><pre><code class="language-julia">A = randn(500,20)
df = DataFrame(A, :auto)
X0,y0 = series_to_supervised(df[:,1:end-1], df[:,end])
X1,y1 = series2supervised(
    df[:,1:end-1] =&gt; range(-6, -1; step=1),
    df[:,end] =&gt; range(0, 0; step=-1)
    )</code></pre><p><strong>NOTICE!</strong></p><p>The input DataFrame (<code>df</code>) must have complete rows; that is, the corresponding time tag (it might be <code>df.datetime</code> for example) must be consecutive because <code>df</code> is converted to <code>Matrix</code> and shifted using <code>lag</code>.</p><p><strong>References:</strong></p><ul><li>https://machinelearningmastery.com/convert-time-series-supervised-learning-problem-python/</li></ul><p><strong>TODO: write test for series2supervised, by making sure the datetime shift is correct (e.g., &quot;datetime<em>t0&quot; should always be 1 hour ahead of &quot;datetime</em>t-6&quot; for a 10-minute sampling data).</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/series2supervised.jl#L39-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.shrinkylim!-Tuple{Any, Vector{&lt;:Number}}" href="#SWCForecast.shrinkylim!-Tuple{Any, Vector{&lt;:Number}}"><code>SWCForecast.shrinkylim!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>shrinkylim!(ax, ydatas::Vector{&lt;:Number}; extent = 0.15)</code> fit y-limits to the input <code>ydatas</code> to with a certain <code>extent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/makietools.jl#L124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.split_time_tag-Tuple{AbstractString}" href="#SWCForecast.split_time_tag-Tuple{AbstractString}"><code>SWCForecast.split_time_tag</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>split_time_tag(str)</code> split the feature name into variable name and the time-shift tag (which should be at the last).</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; split_time_tag(&quot;Soil_water_content_10cm_t-24&quot;)
(&quot;Soil_water_content_10cm&quot;, &quot;t-24&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/format_time_tag.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.symmquantile-Tuple{Any, Any}" href="#SWCForecast.symmquantile-Tuple{Any, Any}"><code>SWCForecast.symmquantile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get symmetric quantile. E.g., <code>symmquantile(y, 0.15)</code> returns <code>quantile(y, [0.15, 0.85])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/quickplots/multibands.jl#L39-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.targetrange-Tuple{Vector, Any, Regex}" href="#SWCForecast.targetrange-Tuple{Vector, Any, Regex}"><code>SWCForecast.targetrange</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>Vector</code>, <code>targetrange(mdcs::Vector, nlevel, exprh::Regex)</code> find the target <code>Markdown.Header{nlevel}</code> object whose content matches <code>exprh</code>, returning a range which starts from this header to the next header <code>Markdown.Header{nlevelnext}</code> where <code>nlevelnext ≤ nlevel</code>.</p><p>Also see <code>islevel</code>, <code>islevelleq</code> and <code>targetsection</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.targetsection-Tuple{Markdown.MD, Any, Any}" href="#SWCForecast.targetsection-Tuple{Markdown.MD, Any, Any}"><code>SWCForecast.targetsection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a <code>Markdown.MD</code> object, <code>targetsection(md1::Markdown.MD, nlevel, exprh)</code> returns the section (which is a <code>Vector</code>) that starts with the <code>Markdown.Header{nlevel}</code> object whose content matches <code>exprh</code> and ends until the next header <code>Markdown.Header{nlevelnext}</code> where <code>nlevelnext ≤ nlevel</code>.</p><p>Also see <code>targetrange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/collectresult.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.toordinal-Tuple" href="#SWCForecast.toordinal-Tuple"><code>SWCForecast.toordinal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>toordinal(v...)</code> does <code>toordinal(DateTime(v...))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/datenum.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.toordinal-Tuple{Dates.DateTime}" href="#SWCForecast.toordinal-Tuple{Dates.DateTime}"><code>SWCForecast.toordinal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>toordinal(dt::DateTime)</code>converts a Julia DateTime to a python style DateNumber. Also see <code>datenum</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/datenum.jl#L17-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.tree_structure-Tuple{Any, DescriptOneTree, Any}" href="#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree, Any}"><code>SWCForecast.tree_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Consider deprecate this function</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.tree_structure-Tuple{Any, DescriptOneTree}" href="#SWCForecast.tree_structure-Tuple{Any, DescriptOneTree}"><code>SWCForecast.tree_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given the machine <code>mach</code>, print the structure of tree to the output variable <code>tree_info::string</code> using <code>MLJDecisionTreeInterface.DT.print_tree</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">tree_info = tree_structure(mach)</code></pre><p><strong>Consider deprecate this function</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L108-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.tree_structure-Tuple{MLJBase.Machine, DescriptCompTree}" href="#SWCForecast.tree_structure-Tuple{MLJBase.Machine, DescriptCompTree}"><code>SWCForecast.tree_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>WARNING</strong></p><p>Your pipeline must have the field <code>selector = FeatureSelector()</code>, e.g.,</p><pre><code class="language-julia">
mypipe = Pipeline(
    selector = FeatureSelector(),
    model = model
)

tuned_model = TunedModel(;
    model=mypipe)

mach = machine(
    tuned_model,
    X, # a dataframe
    y, # a vector
)

mach_report = report(mach)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L143-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.treeinspect!-Tuple{FeatureCounts, DecisionTree.Root}" href="#SWCForecast.treeinspect!-Tuple{FeatureCounts, DecisionTree.Root}"><code>SWCForecast.treeinspect!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>treeinspect!(FC::FeatureCounts, WEE1::DecisionTree.Root)</code> recursively obtain the feature names and splitting thresholds of the tree nodes. Also see <code>FeatureCounts</code>.</p><p><strong>Example</strong></p><p>First, obtain the <code>DecisionTree.Root</code> object from the trained machine containing model of decision tree.</p><pre><code class="language-julia">ftpr = fitted_params(mach1)
transformers = [v for (k, v) in ftpr.fitted_params_given_machine]
featnames = transformers[1].features_to_keep .|&gt; string
WE = transformers[2].fitresult # WrappedEnsemble
WEE1 = WE.ensemble[1]</code></pre><blockquote><p><strong>WARNING</strong>: how the <code>DecisionTree.Root</code> object <code>WEE1</code> depends on the structure of your composite model.</p></blockquote><p>Second, put the <code>DecisionTree.Root</code> object into <code>treeinspect!</code></p><pre><code class="language-julia">FC = FeatureCounts(4) # to at most 4th level
treeinspect!(FC, WEE1)</code></pre><p>In final (optional), output the table</p><pre><code class="language-julia-repl">julia&gt; DataFrame(FC; feature_names=featnames)
13×3 DataFrame
 Row │ feature                  value    level
     │ Any                      Any      Any
─────┼─────────────────────────────────────────
   1 │ precipitation_1d_t0      79.3     1
   2 │ precipitation_3d_t-2     4.9      2
   3 │ precipitation_12hr_t0    47.25    2
   4 │ humidity_CWB_t-6         81.5009  3
   5 │ precipitation_1d_t0      7.75     3
   6 │ humidity_CWB_t-24        94.2036  3
   7 │ precipitation_1hr_t-2    2.0      3
   8 │ precipitation_3d_t-24    0.65     4
   9 │ air_temperature_t-4      13.703   4
  10 │ precipitation_1d_t-18    1.4      4
  11 │ precipitation_12hr_t0    20.25    4
  12 │ precipitation_12hr_t-12  49.5     4
  13 │ precipitation_1hr_t0     2.0      4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/decisiontree.jl#L221-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SWCForecast.writedescription-Tuple{AbstractDescription}" href="#SWCForecast.writedescription-Tuple{AbstractDescription}"><code>SWCForecast.writedescription</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>writedescription(D::AbstractDescription)</code> create file and print <code>D.description</code> to <code>&quot;description.toml&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/okatsn/SWCForecast.jl/blob/4bcf794d79f655a18f5a37fb32ffe2c5007a78e0/src/myreport/description.jl#L31-L33">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 December 2022 01:30">Monday 5 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
